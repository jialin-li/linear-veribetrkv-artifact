  var Length: int  // immutable
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(): bool
    reads reads()
  function reads(): set<object?>
    reads reads()
  function requires(x0: T0, x1: T1, x2: T2): bool
    reads reads(x0, x1, x2)
  function reads(x0: T0, x1: T1, x2: T2): set<object?>
    reads reads(x0, x1, x2)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3): bool
    reads reads(x0, x1, x2, x3)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3): set<object?>
    reads reads(x0, x1, x2, x3)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5): bool
    reads reads(x0, x1, x2, x3, x4, x5)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7): bool
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8): bool
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6): bool
    reads reads(x0, x1, x2, x3, x4, x5, x6)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5, x6)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4): bool
    reads reads(x0, x1, x2, x3, x4)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4): set<object?>
    reads reads(x0, x1, x2, x3, x4)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8, x9: T9): bool
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8, x9: T9): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1, x2: T2): bool
    reads reads(x0, x1, x2)
  function reads(x0: T0, x1: T1, x2: T2): set<object?>
    reads reads(x0, x1, x2)
  function requires(): bool
    reads reads()
  function reads(): set<object?>
    reads reads()
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(x0: T0, x1: T1, x2: T2): bool
    reads reads(x0, x1, x2)
  function reads(x0: T0, x1: T1, x2: T2): set<object?>
    reads reads(x0, x1, x2)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(): bool
    reads reads()
  function reads(): set<object?>
    reads reads()
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3): bool
    reads reads(x0, x1, x2, x3)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3): set<object?>
    reads reads(x0, x1, x2, x3)
  predicate ValidStackSlots(s: BBC.Variables, stack: seq<BT.G.Reference>, slots: seq<uint64>)
  {
    |stack| == |slots| + 1 &&
    s.Ready? &&
    (forall j: int | 0 <= j < |stack| :: 
      stack[j] in s.cache) &&
    (forall j: int | 0 <= j < |stack| - 1 :: 
      s.cache[stack[j]].children.Some?) &&
    (forall j: int | 0 <= j < |stack| - 1 :: 
      slots[j] as int < |s.cache[stack[j]].children.value| <= MaxNumChildren()) &&
    forall j: int | 0 <= j < |stack| - 1 :: 
      slots[j] as int < |s.cache[stack[j]].children.value| <= MaxNumChildren()
  }
  predicate ValidAction(s: BBC.Variables, action: Action)
  {
    s.Ready? &&
    (action.ActionPageIn? ==>
      action.ref in s.ephemeralIndirectionTable.graph &&
      action.ref !in s.cache &&
      action.ref in s.ephemeralIndirectionTable.locs &&
      s.totalCacheSize() <= MaxCacheSize() - 1) &&
    (action.ActionSplit? || action.ActionFlush? ==>
      action.parentref in s.ephemeralIndirectionTable.graph &&
      action.parentref in s.cache &&
      s.cache[action.parentref].children.Some? &&
      0 <= action.slot as int < |s.cache[action.parentref].children.value| &&
      s.cache[action.parentref].children.value[action.slot] in s.cache &&
      s.cache[action.parentref].children.value[action.slot] in s.ephemeralIndirectionTable.graph) &&
    (action.ActionSplit? ==>
      |s.cache[s.cache[action.parentref].children.value[action.slot]].buckets| >= 2 &&
      |s.cache[action.parentref].buckets| <= MaxNumChildren() - 1 &&
      s.totalCacheSize() <= MaxCacheSize() - 2) &&
    (action.ActionFlush? ==>
      true &&
      s.totalCacheSize() <= MaxCacheSize() - 1) &&
    (action.ActionGrow? ==>
      true &&
      s.totalCacheSize() <= MaxCacheSize() - 1) &&
    (action.ActionRepivot? ==>
      action.ref in s.ephemeralIndirectionTable.graph &&
      action.ref in s.cache &&
      s.cache[action.ref].children.None? &&
      |s.cache[action.ref].buckets| == 1)
  }
  function {:opaque} {:fuel 0, 0} getActionToSplit(s: BBC.Variables, stack: seq<BT.G.Reference>, slots: seq<uint64>, i: uint64): (action: Action)
    requires 0 <= i as int < |stack|
    requires ValidStackSlots(s, stack, slots)
  {
    if i == 0 then
      if s.totalCacheSize() <= MaxCacheSize() - 1 then
        ActionGrow
      else
        ActionEvict
    else if |s.cache[stack[i - 1]].children.value| as uint64 < MaxNumChildren() as uint64 then
      if |s.cache[stack[i]].buckets| == 1 then
        ActionRepivot(stack[i])
      else if s.totalCacheSize() <= MaxCacheSize() - 2 then
        ActionSplit(stack[i - 1], slots[i - 1])
      else
        ActionEvict
    else
      getActionToSplit(s, stack, slots, i - 1)
  }
  function {:opaque} {:fuel 0, 0} getActionToFlush(s: BBC.Variables, stack: seq<BT.G.Reference>, slots: seq<uint64>): (BBC.Variables, Action)
    requires |stack| <= 40
    requires ValidStackSlots(s, stack, slots)
    requires BBC.Inv(s)
    decreases 18446744073709551616 - |stack|
  {
    if |stack| as uint64 == 40 then
      (s, ActionFail)
    else
      ghost var ref: NativeTypes.uint64 := stack[|stack| as uint64 - 1]; ghost var node: G.Node := s.cache[ref]; if node.children.None? || |node.buckets| == MaxNumChildren() then (s, getActionToSplit(s, stack, slots, |stack| as uint64 - 1)) else var (slot: uint64, slotWeight: uint64) := biggestSlot(node.buckets); if |node.buckets| < 8 then ghost var childref: NativeTypes.uint64 := node.children.value[slot]; if childref in s.cache then ghost var child: G.Node := s.cache[childref]; ghost var s1: BC.Variables := s; ghost var childTotalWeight: uint64 := WeightBucketList(child.buckets) as uint64; if childTotalWeight + FlushTriggerWeight() as uint64 <= MaxTotalBucketWeight() as uint64 then if s1.totalCacheSize() <= MaxCacheSize() - 1 then (s1, ActionFlush(ref, slot)) else (s1, ActionEvict) else getActionToFlush(s1, stack + [childref], slots + [slot]) else if s.totalCacheSize() <= MaxCacheSize() - 1 then (s, ActionPageIn(childref)) else (s, ActionEvict) else (s, getActionToSplit(s, stack, slots, |stack| as uint64 - 1))
  }
  lemma getActionToSplitValidAction(s: BBC.Variables, stack: seq<BT.G.Reference>, slots: seq<uint64>, i: uint64)
    requires 0 <= i as int < |stack|
    requires BBC.Inv(s)
    requires ValidStackSlots(s, stack, slots)
    requires forall j: int | 0 <= j < |stack| :: stack[j] in s.ephemeralIndirectionTable.graph
    requires forall j: int | 0 <= j < |stack| - 1 :: s.cache[stack[j]].children.value[slots[j]] == stack[j + 1]
    requires s.cache[stack[|stack| - 1]].children.Some? ==> |s.cache[stack[|stack| - 1]].buckets| >= 2
    requires i as int < |stack| - 1 ==> |s.cache[stack[i]].buckets| >= MaxNumChildren()
    ensures ValidAction(s, getActionToSplit(s, stack, slots, i))
    ensures ghost var action: Action := getActionToSplit(s, stack, slots, i); action.ActionGrow? || action.ActionRepivot? || action.ActionSplit? || action.ActionEvict?
  {
    reveal_getActionToSplit();
    ghost var action: Action := getActionToSplit(s, stack, slots, i);
    if i == 0 {
    } else {
      if |s.cache[stack[i - 1]].children.value| as uint64 < MaxNumChildren() as uint64 {
      } else {
        getActionToSplitValidAction(s, stack, slots, i - 1);
      }
    }
  }
  lemma getActionToFlushValidAction(s: BBC.Variables, stack: seq<BT.G.Reference>, slots: seq<uint64>)
    requires |stack| <= 40
    requires ValidStackSlots(s, stack, slots)
    requires BBC.Inv(s)
    requires forall j: int | 0 <= j < |stack| :: stack[j] in s.ephemeralIndirectionTable.graph
    requires forall j: int | 0 <= j < |stack| - 1 :: s.cache[stack[j]].children.value[slots[j]] == stack[j + 1]
    ensures var (s': BBC.Variables, action: Action) := getActionToFlush(s, stack, slots); ValidAction(s', action) && s == s'
    decreases 18446744073709551616 - |stack|
  {
    reveal_getActionToFlush();
    ghost var action: Action := getActionToFlush(s, stack, slots).1;
    if |stack| as uint64 == 40 {
    } else {
      ghost var ref: NativeTypes.uint64 := stack[|stack| as uint64 - 1];
      ghost var node: G.Node := s.cache[ref];
      if node.children.None? || |node.buckets| == MaxNumChildren() {
        getActionToSplitValidAction(s, stack, slots, |stack| as uint64 - 1);
      } else {
        var (slot: uint64, slotWeight: uint64) := biggestSlot(node.buckets);
        if |node.buckets| < 8 {
          ghost var childref: NativeTypes.uint64 := node.children.value[slot];
          lemmaChildInGraph(s, ref, childref);
          if childref in s.cache {
            ghost var child: G.Node := s.cache[childref];
            ghost var s1: BBC.Variables := s;
            ghost var childTotalWeight: uint64 := WeightBucketList(child.buckets) as uint64;
            if childTotalWeight + FlushTriggerWeight() as uint64 <= MaxTotalBucketWeight() as uint64 {
              assert ValidAction(s1, action);
            } else {
              getActionToFlushValidAction(s1, stack + [childref], slots + [slot]);
            }
          } else {
            assert childref !in s.cache;
            assert childref in s.ephemeralIndirectionTable.graph;
            assert childref in s.ephemeralIndirectionTable.locs;
            assert ValidAction(s, action);
          }
        } else {
          getActionToSplitValidAction(s, stack, slots, |stack| as uint64 - 1);
        }
      }
    }
  }
Dafny program verifier did not attempt verification