  var Length: int  // immutable
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(): bool
    reads reads()
  function reads(): set<object?>
    reads reads()
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(x0: T0, x1: T1, x2: T2): bool
    reads reads(x0, x1, x2)
  function reads(x0: T0, x1: T1, x2: T2): set<object?>
    reads reads(x0, x1, x2)
  function requires(x0: T0, x1: T1, x2: T2): bool
    reads reads(x0, x1, x2)
  function reads(x0: T0, x1: T1, x2: T2): set<object?>
    reads reads(x0, x1, x2)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4): bool
    reads reads(x0, x1, x2, x3, x4)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4): set<object?>
    reads reads(x0, x1, x2, x3, x4)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6): bool
    reads reads(x0, x1, x2, x3, x4, x5, x6)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5, x6)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8, x9: T9): bool
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8, x9: T9): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8): bool
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3): bool
    reads reads(x0, x1, x2, x3)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3): set<object?>
    reads reads(x0, x1, x2, x3)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5): bool
    reads reads(x0, x1, x2, x3, x4, x5)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(): bool
    reads reads()
  function reads(): set<object?>
    reads reads()
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(): bool
    reads reads()
  function reads(): set<object?>
    reads reads()
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1, x2: T2): bool
    reads reads(x0, x1, x2)
  function reads(x0: T0, x1: T1, x2: T2): set<object?>
    reads reads(x0, x1, x2)
  function requires(x0: T0, x1: T1, x2: T2): bool
    reads reads(x0, x1, x2)
  function reads(x0: T0, x1: T1, x2: T2): set<object?>
    reads reads(x0, x1, x2)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7): bool
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7)
  function requires(x0: T0, x1: T1, x2: T2): bool
    reads reads(x0, x1, x2)
  function reads(x0: T0, x1: T1, x2: T2): set<object?>
    reads reads(x0, x1, x2)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3): bool
    reads reads(x0, x1, x2, x3)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3): set<object?>
    reads reads(x0, x1, x2, x3)
  lemma jcNoOp(s: Full, s': Full, vop: VOp)
    requires s.jc.WF()
    requires s.jc == s'.jc
    requires vop.StatesInternalOp? || vop.JournalInternalOp? || (vop.AdvanceOp? && vop.uiop.NoOp? && s.jc.status.StatusReady? && vop.replay)
    ensures JC.Next(s.jc.I(), s'.jc.I(), JournalDisk.NoDiskOp, vop)
  {
    if vop.AdvanceOp? {
      assert JC.Replay(s.jc.I(), s'.jc.I(), JournalDisk.NoDiskOp, vop);
      assert JC.NextStep(s.jc.I(), s'.jc.I(), JournalDisk.NoDiskOp, vop, JC.ReplayStep);
    } else {
      assert JC.NoOp(s.jc.I(), s'.jc.I(), JournalDisk.NoDiskOp, vop);
      assert JC.NextStep(s.jc.I(), s'.jc.I(), JournalDisk.NoDiskOp, vop, JC.NoOpStep);
    }
  }
  lemma bcNoOp(s: Full, s': Full, vop: VOp)
    requires s.bc.W()
    requires s.bc == s'.bc
    requires vop.StatesInternalOp? || vop.JournalInternalOp? || vop.PushSyncOp? || vop.PopSyncOp?
    ensures BBC.Next(s.bc.I(), s'.bc.I(), BlockDisk.NoDiskOp, vop)
  {
    assert BC.NoOp(s.bc.I(), s'.bc.I(), BlockDisk.NoDiskOp, vop);
    assert BC.NextStep(s.bc.I(), s'.bc.I(), BlockDisk.NoDiskOp, vop, BC.NoOpStep);
    assert BBC.NextStep(s.bc.I(), s'.bc.I(), BlockDisk.NoDiskOp, vop, BBC.BlockCacheMoveStep(BC.NoOpStep));
  }
  lemma noop(s: Full)
    requires s.W()
    ensures M.Next(s.I(), s.I(), UI.NoOp, D.NoDiskOp)
  {
    jcNoOp(s, s, StatesInternalOp);
    bcNoOp(s, s, StatesInternalOp);
    assert BJC.NextStep(s.I(), s.I(), UI.NoOp, IDiskOp(D.NoDiskOp), StatesInternalOp);
  }
  method pushSync(inout s: Full) returns (id: uint64)
  {
    id := s.jc.pushSync();
    ghost var uiop: Op := if id == 0 then UI.NoOp else UI.PushSyncOp(id as int);
    ghost var vop: VOp := if id == 0 then JournalInternalOp else PushSyncOp(id as int);
    bcNoOp(old_s, s, vop);
    assert BJC.NextStep(old_s.I(), s.I(), uiop, BJD.DiskOp(BlockDisk.NoDiskOp, JournalDisk.NoDiskOp), vop);
    assert BJC.Next(old_s.I(), s.I(), uiop, BJD.DiskOp(BlockDisk.NoDiskOp, JournalDisk.NoDiskOp));
    assert M.Next(old_s.I(), s.I(), if id == 0 then UI.NoOp else UI.PushSyncOp(id as int), D.NoDiskOp);
  }
  method receiveLoc(inout s: Variables, loc: DiskLayout.Location)
  {
    var Unready() := s;
    s := Variables.Loading(loc, None);
    assert BC.ReceiveLoc(old_s.I(), s.I(), BlockDisk.NoDiskOp, SendPersistentLocOp(loc));
    assert BC.NextStep(old_s.I(), s.I(), BlockDisk.NoDiskOp, SendPersistentLocOp(loc), BC.ReceiveLocStep);
    assert BBC.NextStep(old_s.I(), s.I(), BlockDisk.NoDiskOp, SendPersistentLocOp(loc), BBC.BlockCacheMoveStep(BC.ReceiveLocStep));
  }
  method initialization(inout s: Full, io: DiskIOHandler)
    modifies io
  {
    if s.jc.status.StatusLoadingSuperblock? {
      if s.jc.superblock1.SuperblockSuccess? && s.jc.superblock2.SuperblockSuccess? {
        s.jc.finishLoadingSuperblockPhase();
        var loc: Location := s.jc.superblock.indirectionTableLoc;
        receiveLoc(inout s.bc, loc);
        assert BJC.NextStep(old_s.I(), s.I(), UI.NoOp, IDiskOp(diskOp(IIO(io))), SendPersistentLocOp(loc));
        assert BJC.Next(old_s.I(), s.I(), UI.NoOp, IDiskOp(diskOp(IIO(io))));
        assert M.Next(old_s.I(), s.I(), UI.NoOp, diskOp(IIO(io)));
      } else if s.jc.superblock1Read.None? && s.jc.superblock1.SuperblockUnfinished? {
        s.jc.pageInSuperblockReq(io, 0);
        bcNoOp(old_s, s, JournalInternalOp);
        assert BJC.NextStep(old_s.I(), s.I(), UI.NoOp, IDiskOp(diskOp(IIO(io))), JournalInternalOp);
        assert BJC.Next(old_s.I(), s.I(), UI.NoOp, IDiskOp(diskOp(IIO(io))));
        assert M.Next(old_s.I(), s.I(), UI.NoOp, diskOp(IIO(io)));
      } else if s.jc.superblock2Read.None? && s.jc.superblock2.SuperblockUnfinished? {
        s.jc.pageInSuperblockReq(io, 1);
        bcNoOp(old_s, s, JournalInternalOp);
        assert BJC.NextStep(old_s.I(), s.I(), UI.NoOp, IDiskOp(diskOp(IIO(io))), JournalInternalOp);
        assert BJC.Next(old_s.I(), s.I(), UI.NoOp, IDiskOp(diskOp(IIO(io))));
        assert M.Next(old_s.I(), s.I(), UI.NoOp, diskOp(IIO(io)));
      } else {
        print "initialization: doing nothing, superblock reads out\n";
        noop(s);
      }
    } else if s.jc.status.StatusLoadingOther? {
      s.jc.tryFinishLoadingOtherPhase(io);
      bcNoOp(old_s, s, JournalInternalOp);
      assert BJC.NextStep(old_s.I(), s.I(), UI.NoOp, IDiskOp(diskOp(IIO(io))), JournalInternalOp);
      assert BJC.Next(old_s.I(), s.I(), UI.NoOp, IDiskOp(diskOp(IIO(io))));
      assert M.Next(old_s.I(), s.I(), UI.NoOp, diskOp(IIO(io)));
    } else if s.bc.Loading? && s.bc.indirectionTableRead.None? {
      IOImpl.PageInIndirectionTableReq(inout s.bc, io);
      jcNoOp(old_s, s, StatesInternalOp);
      assert BJC.NextStep(old_s.I(), s.I(), UI.NoOp, IDiskOp(diskOp(IIO(io))), StatesInternalOp);
      assert BJC.Next(old_s.I(), s.I(), UI.NoOp, IDiskOp(diskOp(IIO(io))));
      assert M.Next(old_s.I(), s.I(), UI.NoOp, diskOp(IIO(io)));
    } else if s.bc.Ready? {
      var isEmpty: bool := s.jc.isReplayEmpty();
      if !isEmpty {
        var je: JournalEntry := s.jc.journalist.replayJournalTop();
        var success: bool := InsertImpl.insert(inout s.bc, io, je.key, je.value, true);
        if success {
          s.jc.journalReplayOne(je);
        }
        ghost var g: bool := true;
        if g && !success && old_s.jc == s.jc {
          ghost var vop: VOp;
          if BBC.Next(old_s.bc.I(), s.bc.I(), IDiskOp(diskOp(IIO(io))).bdop, StatesInternalOp) {
            vop := StatesInternalOp;
          } else {
            vop := AdvanceOp(UI.NoOp, true);
          }
          jcNoOp(old_s, s, vop);
          assert BJC.NextStep(old_s.I(), s.I(), UI.NoOp, IDiskOp(diskOp(IIO(io))), vop);
          assert BJC.Next(old_s.I(), s.I(), UI.NoOp, IDiskOp(diskOp(IIO(io))));
          assert M.Next(old_s.I(), s.I(), UI.NoOp, diskOp(IIO(io)));
        } else {
          ghost var vop: VOp := AdvanceOp(UI.PutOp(je.key, je.value), true);
          assert BJC.NextStep(old_s.I(), s.I(), UI.NoOp, IDiskOp(diskOp(IIO(io))), vop);
          assert BJC.Next(old_s.I(), s.I(), UI.NoOp, IDiskOp(diskOp(IIO(io))));
          assert M.Next(old_s.I(), s.I(), UI.NoOp, diskOp(IIO(io)));
        }
      } else {
        print "initialization: doing nothing, no replay journal\n";
        noop(s);
      }
    } else {
      print "initialization: doing nothing\n";
      noop(s);
    }
  }
  method doSync(inout s: Full, io: DiskIOHandler, graphSync: bool)
      returns (wait: bool)
    modifies io
  {
    wait := false;
    if s.jc.isFrozen {
      if s.jc.frozenLoc.Some? {
        wait := s.jc.tryAdvanceLocation(io);
        ghost var uiop: Op := UI.NoOp;
        ghost var vop: VOp := JournalInternalOp;
        bcNoOp(old_s, s, vop);
        assert BJC.NextStep(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))), vop);
        assert BJC.Next(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))));
        assert M.Next(old_s.I(), s.I(), uiop, diskOp(IIO(io)));
      } else {
        var froze: bool, wait0: bool := SyncImpl.sync(inout s.bc, io);
        wait := wait0;
        assert froze == false;
        ghost var uiop: Op := UI.NoOp;
        assert BBC.Next(old_s.bc.I(), s.bc.I(), IDiskOp(diskOp(IIO(io))).bdop, StatesInternalOp) || BBC.Next(old_s.bc.I(), s.bc.I(), IDiskOp(diskOp(IIO(io))).bdop, AdvanceOp(UI.NoOp, true));
        if BBC.Next(old_s.bc.I(), s.bc.I(), IDiskOp(diskOp(IIO(io))).bdop, StatesInternalOp) {
          ghost var vop: VOp := StatesInternalOp;
          jcNoOp(old_s, s, vop);
          assert BJC.NextStep(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))), vop);
          assert BJC.Next(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))));
          assert M.Next(old_s.I(), s.I(), UI.NoOp, diskOp(IIO(io)));
        } else {
          ghost var vop: VOp := AdvanceOp(UI.NoOp, true);
          assert BBC.Next(old_s.bc.I(), s.bc.I(), IDiskOp(diskOp(IIO(io))).bdop, vop);
          jcNoOp(old_s, s, vop);
          assert BJC.NextStep(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))), vop);
          assert BJC.Next(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))));
          assert M.Next(old_s.I(), s.I(), UI.NoOp, diskOp(IIO(io)));
        }
      }
    } else if s.jc.superblockWrite.Some? {
      wait := true;
      noop(s);
    } else {
      if graphSync {
        var froze: bool, wait0: bool := SyncImpl.sync(inout s.bc, io);
        wait := wait0;
        if froze {
          s.jc.freeze();
          assert BJC.NextStep(old_s.I(), s.I(), UI.NoOp, IDiskOp(diskOp(IIO(io))), FreezeOp);
          assert BJC.Next(old_s.I(), s.I(), UI.NoOp, IDiskOp(diskOp(IIO(io))));
          assert M.Next(old_s.I(), s.I(), UI.NoOp, diskOp(IIO(io)));
        } else {
          ghost var uiop: Op := UI.NoOp;
          if BBC.Next(old_s.bc.I(), s.bc.I(), IDiskOp(diskOp(IIO(io))).bdop, StatesInternalOp) {
            ghost var vop: VOp := StatesInternalOp;
            jcNoOp(old_s, s, vop);
            assert BJC.NextStep(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))), vop);
            assert BJC.Next(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))));
            assert M.Next(old_s.I(), s.I(), UI.NoOp, diskOp(IIO(io)));
          } else {
            ghost var vop: VOp := AdvanceOp(UI.NoOp, true);
            assert BBC.Next(old_s.bc.I(), s.bc.I(), IDiskOp(diskOp(IIO(io))).bdop, vop);
            jcNoOp(old_s, s, vop);
            assert BJC.NextStep(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))), vop);
            assert BJC.Next(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))));
            assert M.Next(old_s.I(), s.I(), UI.NoOp, diskOp(IIO(io)));
          }
          assert M.Next(old_s.I(), s.I(), UI.NoOp, diskOp(IIO(io)));
        }
      } else {
        wait := s.jc.tryAdvanceLog(io);
        ghost var uiop: Op := UI.NoOp;
        ghost var vop: VOp := JournalInternalOp;
        bcNoOp(old_s, s, vop);
        assert BJC.NextStep(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))), vop);
        assert BJC.Next(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))));
        assert M.Next(old_s.I(), s.I(), UI.NoOp, diskOp(IIO(io)));
      }
    }
  }
  method getCommitterSyncState(s: Full, id: uint64) returns (res: Option<JC.SyncReqStatus>)
    requires s.Inv()
    ensures var contents: map<uint64, JC.SyncReqStatus> := s.jc.syncReqs.contents; (if id in contents then res == Some(contents[id]) else res.None?) && (res.Some? <==> id in s.jc.syncReqs.contents)
  {
    res := LinearMutableMap.Get(s.jc.syncReqs, id);
  }
  function method isCommitterStatusReady(s: Full): bool
    requires s.WF()
  {
    s.jc.status.StatusReady?
  }
  function method isInitialized(s: Full): (b: bool)
    requires s.Inv()
  {
    if s.bc.Ready? && isCommitterStatusReady(s) then
      s.jc.isReplayEmpty()
    else
      false
  }
  method popSync(inout s: Full, io: DiskIOHandler, id: uint64, graphSync: bool)
      returns (success: bool, wait: bool)
    modifies io
  {
    wait := false;
    var committerSyncState: Option<JC.SyncReqStatus> := getCommitterSyncState(s, id);
    assert committerSyncState.Some? <==> id in s.jc.syncReqs.contents;
    if committerSyncState == Some(JC.State1) {
      s.jc.popSync(id);
      success := true;
      ghost var uiop: Op := if success then UI.PopSyncOp(id as int) else UI.NoOp;
      ghost var vop: VOp := if success then PopSyncOp(id as int) else JournalInternalOp;
      bcNoOp(old_s, s, vop);
      assert BJC.NextStep(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))), vop);
      assert BJC.Next(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))));
      assert M.Next(old_s.I(), s.I(), uiop, diskOp(IIO(io)));
    } else {
      var isInit: bool := isInitialized(s);
      if !isInit {
        initialization(inout s, io);
        success := false;
        assert M.Next(old_s.I(), s.I(), UI.NoOp, diskOp(IIO(io)));
      } else {
        wait := doSync(inout s, io, graphSync);
        success := false;
      }
    }
  }
  method query(inout s: Full, io: DiskIOHandler, key: Key)
      returns (result: Option<Value>)
    modifies io
  {
    var is_init: bool := isInitialized(s);
    if !is_init {
      initialization(inout s, io);
      result := None;
    } else {
      result := QueryImpl.query(inout s.bc, io, key);
      if result.Some? {
        ghost var uiop: Op := UI.GetOp(key, result.value);
        ghost var vop: VOp := AdvanceOp(uiop, false);
        assert JC.Advance(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop);
        assert JC.NextStep(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop, JC.AdvanceStep);
        assert JC.Next(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop);
        assert BJC.NextStep(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))), vop);
        assert BJC.Next(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))));
      } else {
        ghost var uiop: Op := UI.NoOp;
        if BBC.Next(old_s.bc.I(), s.bc.I(), IDiskOp(diskOp(IIO(io))).bdop, StatesInternalOp) {
          ghost var vop: VOp := StatesInternalOp;
          assert JC.NoOp(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop);
          assert JC.NextStep(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop, JC.NoOpStep);
          assert JC.Next(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop);
          assert BJC.NextStep(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))), vop);
          assert BJC.Next(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))));
        } else {
          ghost var vop: VOp := AdvanceOp(uiop, true);
          assert JC.Replay(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop);
          assert JC.NextStep(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop, JC.ReplayStep);
          assert JC.Next(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop);
          assert BJC.NextStep(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))), vop);
          assert BJC.Next(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))));
        }
      }
    }
  }
  method succ(inout s: Full, io: DiskIOHandler, start: UI.RangeStart, maxToFind: uint64)
      returns (result: Option<UI.SuccResultList>)
    modifies io
  {
    var is_init: bool := isInitialized(s);
    if !is_init {
      initialization(inout s, io);
      result := None;
    } else {
      result := SuccImpl.doSucc(inout s.bc, io, start, maxToFind);
      if result.Some? {
        ghost var uiop: Op := UI.SuccOp(start, result.value.results, result.value.end);
        ghost var vop: VOp := AdvanceOp(uiop, false);
        assert JC.Advance(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop);
        assert JC.NextStep(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop, JC.AdvanceStep);
        assert JC.Next(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop);
        assert BJC.NextStep(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))), vop);
        assert BJC.Next(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))));
      } else {
        ghost var uiop: Op := UI.NoOp;
        if BBC.Next(old_s.bc.I(), s.bc.I(), IDiskOp(diskOp(IIO(io))).bdop, StatesInternalOp) {
          ghost var vop: VOp := StatesInternalOp;
          assert JC.NoOp(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop);
          assert JC.NextStep(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop, JC.NoOpStep);
          assert JC.Next(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop);
          assert BJC.NextStep(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))), vop);
          assert BJC.Next(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))));
        } else {
          ghost var vop: VOp := AdvanceOp(uiop, true);
          assert JC.Replay(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop);
          assert JC.NextStep(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop, JC.ReplayStep);
          assert JC.Next(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop);
          assert BJC.NextStep(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))), vop);
          assert BJC.Next(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))));
        }
      }
    }
  }
  function method canJournalistAppend(s: Full, key: Key, value: Value): (b: bool)
    requires s.WF()
  {
    s.jc.journalist.canAppend(Journal.JournalInsert(key, value))
  }
  method insert(inout s: Full, io: DiskIOHandler, key: Key, value: Value)
      returns (success: bool)
    modifies io
  {
    var is_init: bool := isInitialized(s);
    if !is_init {
      initialization(inout s, io);
      success := false;
    } else {
      var can_append: bool := canJournalistAppend(s, key, value);
      if can_append {
        success := InsertImpl.insert(inout s.bc, io, key, value, false);
        if success {
          s.jc.journalAppend(key, value);
          ghost var uiop: Op := UI.PutOp(key, value);
          ghost var vop: VOp := AdvanceOp(uiop, false);
          assert BJC.NextStep(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))), vop);
          assert BJC.Next(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))));
        } else {
          ghost var uiop: Op := UI.NoOp;
          if BBC.Next(old_s.bc.I(), s.bc.I(), IDiskOp(diskOp(IIO(io))).bdop, StatesInternalOp) {
            ghost var vop: VOp := StatesInternalOp;
            assert JC.NoOp(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop);
            assert JC.NextStep(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop, JC.NoOpStep);
            assert JC.Next(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop);
            assert BJC.NextStep(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))), vop);
            assert BJC.Next(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))));
          } else {
            ghost var vop: VOp := AdvanceOp(uiop, true);
            assert JC.Replay(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop);
            assert JC.NextStep(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop, JC.ReplayStep);
            assert JC.Next(old_s.jc.I(), s.jc.I(), JournalDisk.NoDiskOp, vop);
            assert BJC.NextStep(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))), vop);
            assert BJC.Next(old_s.I(), s.I(), uiop, IDiskOp(diskOp(IIO(io))));
          }
        }
      } else {
        var wait: bool := doSync(inout s, io, true);
        success := false;
      }
    }
  }
Dafny program verifier did not attempt verification