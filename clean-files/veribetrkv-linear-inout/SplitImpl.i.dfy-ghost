  var Length: int  // immutable
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(): bool
    reads reads()
  function reads(): set<object?>
    reads reads()
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7): bool
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8): bool
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6): bool
    reads reads(x0, x1, x2, x3, x4, x5, x6)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5, x6)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4): bool
    reads reads(x0, x1, x2, x3, x4)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4): set<object?>
    reads reads(x0, x1, x2, x3, x4)
  function requires(x0: T0, x1: T1, x2: T2): bool
    reads reads(x0, x1, x2)
  function reads(x0: T0, x1: T1, x2: T2): set<object?>
    reads reads(x0, x1, x2)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3): bool
    reads reads(x0, x1, x2, x3)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3): set<object?>
    reads reads(x0, x1, x2, x3)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5): bool
    reads reads(x0, x1, x2, x3, x4, x5)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(): bool
    reads reads()
  function reads(): set<object?>
    reads reads()
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(): bool
    reads reads()
  function reads(): set<object?>
    reads reads()
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8, x9: T9): bool
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8, x9: T9): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)
  function requires(x0: T0, x1: T1, x2: T2): bool
    reads reads(x0, x1, x2)
  function reads(x0: T0, x1: T1, x2: T2): set<object?>
    reads reads(x0, x1, x2)
  function requires(x0: T0, x1: T1, x2: T2): bool
    reads reads(x0, x1, x2)
  function reads(x0: T0, x1: T1, x2: T2): set<object?>
    reads reads(x0, x1, x2)
  function requires(x0: T0, x1: T1, x2: T2): bool
    reads reads(x0, x1, x2)
  function reads(x0: T0, x1: T1, x2: T2): set<object?>
    reads reads(x0, x1, x2)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3): bool
    reads reads(x0, x1, x2, x3)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3): set<object?>
    reads reads(x0, x1, x2, x3)
  method computeValidSplitKey(cache: CacheImpl.LMutCache, ref: BT.G.Reference, pivots: PivotTable, lpivot: Key, rpivot: Option<Key>)
      returns (b: bool)
    requires cache.Inv()
    requires cache.ptr(ref).Some?
    requires cache.I()[ref].pivotTable == pivots
    requires BT.WFNode(cache.I()[ref])
    ensures BT.ValidSplitKey(cache.I()[ref], lpivot, rpivot) == b
  {
    var len: uint64 := |pivots| as uint64;
    var valid: bool := ComputeBoundedKey(pivots, lpivot);
    if !valid {
      return false;
    }
    if rpivot.Some? {
      valid := ComputeValidLeftCutOffKey(pivots, rpivot.value);
      if !valid {
        return false;
      }
      var k: Key := ComputeGetKey(pivots, 0);
      var c: int32 := BT.G.KeyspaceImpl.cmp(k, rpivot.value);
      if c >= 0 {
        return false;
      }
      c := BT.G.KeyspaceImpl.cmp(lpivot, rpivot.value);
      if c >= 0 {
        return false;
      }
    } else {
      if pivots[len - 1] != Keyspace.Max_Element {
        return false;
      }
    }
    return true;
  }
  method splitBookkeeping(inout s: ImplVariables, left_childref: BT.G.Reference, right_childref: BT.G.Reference, parentref: BT.G.Reference, fparent_children: seq<BT.G.Reference>, left_child: Node, right_child: Node, slot: uint64)
  {
    SplitModel.reveal_splitBookkeeping();
    BookkeepingModel.lemmaChildrenConditionsPreservedWriteBookkeeping(s.I(), left_childref, left_child.children, right_child.children);
    BookkeepingModel.lemmaChildrenConditionsPreservedWriteBookkeeping(s.I(), left_childref, left_child.children, Some(fparent_children));
    BookkeepingModel.lemmaRefInGraphOfWriteBookkeeping(s.I(), left_childref, left_child.children);
    writeBookkeeping(inout s, left_childref, left_child.children);
    BookkeepingModel.lemmaChildrenConditionsPreservedWriteBookkeeping(s.I(), right_childref, right_child.children, Some(fparent_children));
    BookkeepingModel.lemmaRefInGraphOfWriteBookkeeping(s.I(), right_childref, right_child.children);
    BookkeepingModel.lemmaRefInGraphPreservedWriteBookkeeping(s.I(), right_childref, right_child.children, left_childref);
    writeBookkeeping(inout s, right_childref, right_child.children);
    BookkeepingModel.lemmaChildrenConditionsOfReplace1With2(s.I(), fparent_children, slot as int, left_childref, right_childref);
    var rep: seq<BT.G.Reference> := Replace1with2(fparent_children, left_childref, right_childref, slot);
    writeBookkeeping(inout s, parentref, Some(rep));
  }
  method splitCacheChanges(inout s: ImplVariables, left_childref: BT.G.Reference, right_childref: BT.G.Reference, parentref: BT.G.Reference, slot: uint64, num_children_left: uint64, pivot: Key, left_child: Node, right_child: Node)
  {
    SplitModel.reveal_splitCacheChanges();
    s.cache.Insert(left_childref, left_child);
    s.cache.Insert(right_childref, right_child);
    s.cache.SplitParent(parentref, slot as uint64, pivot, left_childref, right_childref);
    ghost var s': BBC.Variables := SplitModel.splitCacheChanges(old_s.I(), left_childref, right_childref, parentref, slot as int, num_children_left as int, pivot, left_child.I(), right_child.I());
    assert s.W();
    assert s' == s.I();
  }
  method splitDoChanges(inout s: ImplVariables, child: Node, left_childref: BT.G.Reference, right_childref: BT.G.Reference, parentref: BT.G.Reference, fparent_pivots: PivotTable, fparent_children: seq<BT.G.Reference>, slot: uint64)
  {
    var len: uint64 := lseq_length_as_uint64(child.buckets);
    var num_children_left: uint64 := len / 2;
    var pivot: Key := ComputeGetKey(child.pivotTable, num_children_left);
    SplitModel.reveal_splitDoChanges();
    var insertable: bool := ComputePivotInsertable(fparent_pivots, slot + 1, pivot);
    if insertable {
      SplitModel.lemmaChildrenConditionsSplitChild(s.I(), child.I(), num_children_left as int);
      var left_child: Node := child.SplitChildLeft(num_children_left);
      var right_child: Node := child.SplitChildRight(num_children_left);
      splitBookkeeping(inout s, left_childref, right_childref, parentref, fparent_children, left_child, right_child, slot as uint64);
      splitCacheChanges(inout s, left_childref, right_childref, parentref, slot as uint64, num_children_left as uint64, pivot, left_child, right_child);
      calc == {
        LruModel.I(s.lru.Queue());
      ==
        LruModel.I(old_s.lru.Queue()) + {left_childref, right_childref, parentref};
      ==
        old_s.cache.I().Keys + {left_childref, right_childref, parentref};
      ==
        s.cache.I().Keys;
      }
    } else {
      print "giving up; split can't run because new pivots will not be strictly sorted";
    }
    var _: () := FreeNode(child);
  }
  method splitChild(inout s: ImplVariables, parentref: BT.G.Reference, childref: BT.G.Reference, slot: uint64, lbound: Key, ubound: Option<Key>, fparent_pivots: PivotTable, fparent_children: Option<seq<BT.G.Reference>>, refUpperBound: uint64)
  {
    SplitModel.reveal_splitChild();
    var child: Node := s.cache.NodeCutOff(childref, lbound, ubound);
    assert child.I() == BT.CutoffNode(s.cache.I()[childref], lbound, ubound);
    SplitModel.lemmaChildrenConditionsCutoffNode(s.I(), s.cache.I()[childref], lbound, ubound);
    assert BT.WFNode(child.I());
    if |child.pivotTable| as uint64 == 2 {
      print "giving up; doSplit can't run because child pivots can't be splitted\n";
      var _: () := FreeNode(child);
    } else {
      var len: uint64 := lseq_length_as_uint64(child.buckets);
      var num_children_left: uint64 := len / 2;
      var pivot: Key := ComputeGetKey(child.pivotTable, num_children_left);
      BookkeepingModel.getFreeRefDoesntEqual(s.I(), parentref, refUpperBound);
      ghost var gleft_childref: Option<BT.G.Reference> := BookkeepingModel.getFreeRef(s.I(), refUpperBound);
      var left_childref: Option<BT.G.Reference> := getFreeRef(s);
      if left_childref.None? {
        print "giving up; doSplit can't allocate left_childref\n";
        var _: () := FreeNode(child);
      } else {
        BookkeepingModel.getFreeRef2DoesntEqual(s.I(), left_childref.value, parentref, refUpperBound);
        var right_childref: Option<BT.G.Reference> := getFreeRef2(s, left_childref.value);
        if right_childref.None? {
          print "giving up; doSplit can't allocate right_childref\n";
          var _: () := FreeNode(child);
        } else {
          splitDoChanges(inout s, child, left_childref.value, right_childref.value, parentref, fparent_pivots, fparent_children.value, slot as uint64);
        }
      }
    }
  }
  method doSplit(inout s: ImplVariables, parentref: BT.G.Reference, childref: BT.G.Reference, slot: uint64, refUpperBound: uint64)
  {
    SplitModel.reveal_doSplit();
    var b: bool := false;
    if s.frozenIndirectionTable.lSome? {
      b := s.frozenIndirectionTable.value.HasEmptyLoc(parentref);
    }
    if b {
      print "giving up; split can't run because frozen isn't written";
    } else {
      ghost var fused_parent: BT.G.Node := s.cache.I()[parentref];
      ghost var fused_child: BT.G.Node := s.cache.I()[childref];
      var fparent_pivots: seq<Element>, fparent_children: Option<seq<BT.G.Reference>> := s.cache.GetNodeInfo(parentref);
      var fchild_pivots: seq<Element>, _: Option<seq<BT.G.Reference>> := s.cache.GetNodeInfo(childref);
      var childlbound: int32 := KeyspaceImpl.cmp(fchild_pivots[0], fparent_pivots[slot]);
      var childubound: int32 := KeyspaceImpl.cmp(fparent_pivots[slot + 1], fchild_pivots[|fchild_pivots| as uint64 - 1]);
      if childlbound > 0 || childubound > 0 {
        print "giving up; split can't run because splitted keys are not in bound";
      } else {
        BookkeepingModel.lemmaChildrenConditionsOfNode(s.I(), parentref);
        BookkeepingModel.lemmaChildrenConditionsOfNode(s.I(), childref);
        var lbound: Key := ComputeGetKey(fparent_pivots, slot);
        var ubound: Option<Key> := None;
        if fparent_pivots[slot + 1].Element? {
          var ukey: Key := ComputeGetKey(fparent_pivots, slot + 1);
          ubound := Some(ukey);
        }
        assert lbound == BT.getlbound(fused_parent, slot as int);
        assert ubound == BT.getubound(fused_parent, slot as int);
        var childvalid: bool := computeValidSplitKey(s.cache, childref, fchild_pivots, lbound, ubound);
        var parentvalid: bool := computeValidSplitKey(s.cache, parentref, fparent_pivots, lbound, ubound);
        if childvalid && parentvalid {
          assert BT.ValidSplitKey(fused_parent, lbound, ubound);
          assert BT.ValidSplitKey(fused_child, lbound, ubound);
          splitChild(inout s, parentref, childref, slot, lbound, ubound, fparent_pivots, fparent_children, refUpperBound);
        } else {
          print "giving up; split can't run because bounds checking failed";
        }
      }
    }
  }
  method split(inout s: ImplVariables, parentref: BT.G.Reference, childref: BT.G.Reference, slot: uint64)
  {
    var refUpperBound: uint64 := s.ephemeralIndirectionTable.refUpperBound;
    old_s.ephemeralIndirectionTable.UpperBounded();
    SplitModel.doSplitCorrect(s.I(), parentref, childref, slot as int, refUpperBound);
    doSplit(inout s, parentref, childref, slot, refUpperBound);
  }
Dafny program verifier did not attempt verification