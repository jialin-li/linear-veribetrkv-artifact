  var Length: int  // immutable
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(): bool
    reads reads()
  function reads(): set<object?>
    reads reads()
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1, x2: T2): bool
    reads reads(x0, x1, x2)
  function reads(x0: T0, x1: T1, x2: T2): set<object?>
    reads reads(x0, x1, x2)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3): bool
    reads reads(x0, x1, x2, x3)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3): set<object?>
    reads reads(x0, x1, x2, x3)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5): bool
    reads reads(x0, x1, x2, x3, x4, x5)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7): bool
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8): bool
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6): bool
    reads reads(x0, x1, x2, x3, x4, x5, x6)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5, x6)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4): bool
    reads reads(x0, x1, x2, x3, x4)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4): set<object?>
    reads reads(x0, x1, x2, x3, x4)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8, x9: T9): bool
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8, x9: T9): set<object?>
    reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1, x2: T2): bool
    reads reads(x0, x1, x2)
  function reads(x0: T0, x1: T1, x2: T2): set<object?>
    reads reads(x0, x1, x2)
  function requires(): bool
    reads reads()
  function reads(): set<object?>
    reads reads()
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(x0: T0, x1: T1, x2: T2): bool
    reads reads(x0, x1, x2)
  function reads(x0: T0, x1: T1, x2: T2): set<object?>
    reads reads(x0, x1, x2)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(): bool
    reads reads()
  function reads(): set<object?>
    reads reads()
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0): bool
    reads reads(x0)
  function reads(x0: T0): set<object?>
    reads reads(x0)
  function requires(x0: T0, x1: T1): bool
    reads reads(x0, x1)
  function reads(x0: T0, x1: T1): set<object?>
    reads reads(x0, x1)
  function requires(x0: T0, x1: T1, x2: T2): bool
    reads reads(x0, x1, x2)
  function reads(x0: T0, x1: T1, x2: T2): set<object?>
    reads reads(x0, x1, x2)
  function requires(x0: T0, x1: T1, x2: T2, x3: T3): bool
    reads reads(x0, x1, x2, x3)
  function reads(x0: T0, x1: T1, x2: T2, x3: T3): set<object?>
    reads reads(x0, x1, x2, x3)
  method getActionToSplit(s: ImplVariables, stack: seq<BT.G.Reference>, slots: seq<uint64>, i: uint64)
      returns (action: FlushPolicyModel.Action)
    requires 0 <= i as int < |stack|
    requires s.Inv()
    requires FlushPolicyModel.ValidStackSlots(s.I(), stack, slots)
    ensures action == FlushPolicyModel.getActionToSplit(s.I(), stack, slots, i)
  {
    FlushPolicyModel.reveal_getActionToSplit();
    if i == 0 {
      if s.TotalCacheSize() <= MaxCacheSizeUint64() - 1 {
        action := FlushPolicyModel.ActionGrow;
      } else {
        action := FlushPolicyModel.ActionEvict;
      }
    } else {
      var _: Pivots.PivotTable, nodePrevChildren: Option<seq<BT.G.Reference>> := s.cache.GetNodeInfo(stack[i - 1]);
      if |nodePrevChildren.value| as uint64 < MaxNumChildrenUint64() {
        var bucketslen: uint64 := s.cache.GetNodeBucketsLen(stack[i]);
        if bucketslen == 1 {
          action := FlushPolicyModel.ActionRepivot(stack[i]);
        } else {
          if s.TotalCacheSize() <= MaxCacheSizeUint64() - 2 {
            action := FlushPolicyModel.ActionSplit(stack[i - 1], slots[i - 1]);
          } else {
            action := FlushPolicyModel.ActionEvict;
          }
        }
      } else {
        action := getActionToSplit(s, stack, slots, i - 1);
      }
    }
  }
  method {:timeLimitMultiplier 2} getActionToFlush(inout s: ImplVariables, stack: seq<BT.G.Reference>, slots: seq<uint64>)
      returns (action: FlushPolicyModel.Action)
    decreases 18446744073709551616 - |stack|
  {
    FlushPolicyModel.reveal_getActionToFlush();
    if |stack| as uint64 == 40 {
      action := FlushPolicyModel.ActionFail;
    } else {
      var ref: NativeTypes.uint64 := stack[|stack| as uint64 - 1];
      var _: Pivots.PivotTable, children: Option<seq<BT.G.Reference>> := s.cache.GetNodeInfo(ref);
      var bucketslen: uint64 := s.cache.GetNodeBucketsLen(ref);
      if children.None? || bucketslen == MaxNumChildrenUint64() {
        action := getActionToSplit(s, stack, slots, |stack| as uint64 - 1);
      } else {
        var bs: (uint64, uint64) := s.cache.NodeBiggestSlot(ref);
        var (slot: uint64, slotWeight: uint64) := bs;
        if bucketslen as uint64 < 8 {
          var childref: NativeTypes.uint64 := children.value[slot];
          var childincache: bool := s.cache.InCache(childref);
          if childincache {
            s.lru.Use(childref);
            LruModel.LruUse(old_s.lru.Queue(), childref);
            var childTotalWeight: uint64 := s.cache.NodeBucketsWeight(childref);
            if childTotalWeight + FlushTriggerWeightUint64() <= MaxTotalBucketWeightUint64() {
              if s.TotalCacheSize() <= MaxCacheSizeUint64() - 1 {
                action := FlushPolicyModel.ActionFlush(ref, slot);
              } else {
                action := FlushPolicyModel.ActionEvict;
              }
            } else {
              action := getActionToFlush(inout s, stack + [childref], slots + [slot]);
            }
          } else {
            if s.TotalCacheSize() <= MaxCacheSizeUint64() - 1 {
              action := FlushPolicyModel.ActionPageIn(childref);
            } else {
              action := FlushPolicyModel.ActionEvict;
            }
          }
        } else {
          action := getActionToSplit(s, stack, slots, |stack| as uint64 - 1);
        }
      }
    }
  }
  method {:timeLimitMultiplier 2} runFlushPolicy(inout s: ImplVariables, io: DiskIOHandler)
    modifies io
  {
    LruModel.LruUse(s.lru.Queue(), BT.G.Root());
    s.lru.Use(BT.G.Root());
    FlushPolicyModel.getActionToFlushValidAction(s.I(), [BT.G.Root()], []);
    var action: FlushPolicyModel.Action := getActionToFlush(inout s, [BT.G.Root()], []);
    match action {
      case ActionPageIn(ref) =>
        {
          PageInNodeReq(inout s, io, ref);
        }
      case ActionSplit(parentref, slot) =>
        {
          var _, parent_children := s.cache.GetNodeInfo(parentref);
          split(inout s, parentref, parent_children.value[slot], slot);
        }
      case ActionRepivot(ref) =>
        {
          repivotLeaf(inout s, ref);
        }
      case ActionFlush(parentref, slot) =>
        {
          var _, parent_children := s.cache.GetNodeInfo(parentref);
          var childref := parent_children.value[slot];
          flush(inout s, parentref, slot, childref);
        }
      case ActionGrow() =>
        {
          grow(inout s);
        }
      case ActionEvict() =>
        {
          EvictOrDealloc(inout s, io);
        }
      case ActionFail() =>
        {
          assert IOModel.noop(old_s.I(), s.I());
          print "ActionFail\n";
        }
    }
  }
Dafny program verifier did not attempt verification