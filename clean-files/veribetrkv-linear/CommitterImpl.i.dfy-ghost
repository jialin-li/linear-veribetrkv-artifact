// CommitterImpl.i.dfy
module CommitterImpl {
  datatype Status = StatusLoadingSuperblock | StatusLoadingOther | StatusReady
  datatype Committer = Committer(status: Status, journalist: JournalistImpl.Journalist, frozenLoc: Option<Location>, isFrozen: bool, frozenJournalPosition: uint64, superblockWrite: Option<JC.ReqId>, outstandingJournalWrites: set<JC.ReqId>, superblock: Superblock, newSuperblock: Option<Superblock>, whichSuperblock: uint64, commitStatus: JC.CommitStatus, journalFrontRead: Option<JC.ReqId>, journalBackRead: Option<JC.ReqId>, superblock1Read: Option<JC.ReqId>, superblock2Read: Option<JC.ReqId>, superblock1: JC.SuperblockReadResult, superblock2: JC.SuperblockReadResult, syncReqs: LinearMutableMap.LinearHashMap<JC.SyncReqStatus>) {
    predicate WF()
      decreases this
    {
      syncReqs.Inv() &&
      journalist.Inv() &&
      (status == StatusLoadingSuperblock ==>
        journalist.I().inMemoryJournalFrozen == [] &&
        journalist.I().inMemoryJournal == [] &&
        journalist.I().replayJournal == [] &&
        journalist.I().journalFront == None &&
        journalist.I().journalBack == None &&
        (superblock1.SuperblockSuccess? ==>
          JC.WFSuperblock(superblock1.value)) &&
        (superblock2.SuperblockSuccess? ==>
          JC.WFSuperblock(superblock2.value))) &&
      (status == StatusLoadingOther ==>
        journalist.I().inMemoryJournalFrozen == [] &&
        journalist.I().inMemoryJournal == [] &&
        journalist.I().replayJournal == [] &&
        JC.WFSuperblock(superblock)) &&
      (status == StatusReady ==>
        true &&
        JC.WFSuperblock(superblock))
    }
    function I(): JC.Variables
      requires WF()
      decreases this
    {
      match status {
        case StatusLoadingSuperblock() =>
          JC.LoadingSuperblock(superblock1Read, superblock2Read, superblock1, superblock2, syncReqs.contents)
        case StatusLoadingOther() =>
          JC.LoadingOther(superblock, whichSuperblock as int, journalFrontRead, journalBackRead, journalist.I().journalFront, journalist.I().journalBack, syncReqs.contents)
        case StatusReady() =>
          JC.Ready(frozenLoc, isFrozen, frozenJournalPosition as int, superblockWrite, journalist.I().inMemoryJournalFrozen, journalist.I().inMemoryJournal, outstandingJournalWrites, journalist.I().writtenJournalLen, journalist.I().replayJournal, superblock, whichSuperblock as int, commitStatus, newSuperblock, syncReqs.contents)
      }
    }
    predicate Inv()
      decreases this
    {
      WF() &&
      JC.Inv(I())
    }
    static method Constructor() returns (self: Committer)
      ensures self.Inv()
      ensures self.I() == JC.LoadingSuperblock(None, None, JC.SuperblockUnfinished, JC.SuperblockUnfinished, map[])
    {
      var j: Journalist := JournalistImpl.Journalist.Constructor();
      var m: LinearHashMap<JC.SyncReqStatus> := LinearMutableMap.Constructor(128);
      self := Committer(StatusLoadingSuperblock, j, None, false, 0, None, {}, Superblock(0, 0, 0, Location(0, 0)), None, 0, JC.CommitStatus.CommitNone, None, None, None, None, JC.SuperblockUnfinished, JC.SuperblockUnfinished, m);
      assert self.I() == JC.LoadingSuperblock(None, None, JC.SuperblockUnfinished, JC.SuperblockUnfinished, map[]);
    }
    method journalAppend(inout old_self: Committer, key: Key, value: Value)
        returns (self: Committer)
      requires old_self.Inv()
      requires old_self.status == StatusReady
      requires old_self.journalist.canAppend(JournalInsert(key, value))
      requires old_self.I().replayJournal == []
      ensures self.Inv()
      ensures JC.Next(old_self.I(), self.I(), JournalDisk.NoDiskOp, AdvanceOp(UI.PutOp(key, value), false))
      decreases this, old_self, key, value
    {
      self := old_self;
      var je: JournalEntry := JournalInsert(key, value);
      var _inout_tmp_0: Journalist;
      _inout_tmp_0 := self.journalist.append(inout self.journalist, je);
      self := self.(journalist := _inout_tmp_0);
      assert JC.Advance(old_self.I(), self.I(), JournalDisk.NoDiskOp, AdvanceOp(UI.PutOp(key, value), false));
      assert JC.NextStep(old_self.I(), self.I(), JournalDisk.NoDiskOp, AdvanceOp(UI.PutOp(key, value), false), JC.AdvanceStep);
    }
    method journalReplayOne(inout old_self: Committer, ghost je: JournalEntry) returns (self: Committer)
      requires old_self.Inv()
      requires old_self.status == StatusReady
      requires old_self.I().replayJournal != []
      requires je == old_self.I().replayJournal[0]
      ensures self.Inv()
      ensures self.status == StatusReady
      ensures JC.Next(old_self.I(), self.I(), JournalDisk.NoDiskOp, AdvanceOp(UI.PutOp(je.key, je.value), true))
      decreases this, old_self, je
    {
      self := old_self;
      var _inout_tmp_0: Journalist;
      _inout_tmp_0 := self.journalist.replayJournalPop(inout self.journalist);
      self := self.(journalist := _inout_tmp_0);
      ghost var vop: VOp := AdvanceOp(UI.PutOp(je.key, je.value), true);
      assert JC.Replay(old_self.I(), self.I(), JournalDisk.NoDiskOp, vop);
      assert JC.NextStep(old_self.I(), self.I(), JournalDisk.NoDiskOp, vop, JC.ReplayStep);
    }
    method pageInSuperblockReq(inout old_self: Committer, io: DiskIOHandler, which: uint64)
        returns (self: Committer)
      requires old_self.Inv()
      requires which == 0 || which == 1
      requires which == 0 ==> old_self.superblock1.SuperblockUnfinished?
      requires which == 1 ==> old_self.superblock2.SuperblockUnfinished?
      requires old_self.status.StatusLoadingSuperblock?
      requires io.initialized()
      modifies io
      ensures self.Inv()
      ensures ValidDiskOp(diskOp(IIO(io))) && IDiskOp(diskOp(IIO(io))).bdop.NoDiskOp? && JC.Next(old_self.I(), self.I(), IDiskOp(diskOp(IIO(io))).jdop, JournalInternalOp)
      decreases this, old_self, io, which
    {
      self := old_self;
      var loc: Location;
      ghost var step: bool := false;
      if which == 0 {
        loc := Superblock1Location();
        if self.superblock1Read.None? {
          var id: D.ReqId := RequestRead(io, loc);
          var _inout_tmp_0: Option<uint64> := Some(id);
          self := self.(superblock1Read := _inout_tmp_0);
          step := true;
        } else {
          print "PageInSuperblockReq: doing nothing\n";
        }
      } else {
        loc := Superblock2Location();
        if self.superblock2Read.None? {
          var id: D.ReqId := RequestRead(io, loc);
          var _inout_tmp_1: Option<uint64> := Some(id);
          self := self.(superblock2Read := _inout_tmp_1);
          step := true;
        } else {
          print "PageInSuperblockReq: doing nothing\n";
        }
      }
      ghost var jdop: JournalDisk.DiskOp := IDiskOp(diskOp(IIO(io))).jdop;
      if step {
        assert JC.PageInSuperblockReq(old_self.I(), self.I(), jdop, JournalInternalOp, which as int);
        assert JC.NextStep(old_self.I(), self.I(), jdop, JournalInternalOp, JC.PageInSuperblockReqStep(which as int));
      } else {
        assert JC.NoOp(old_self.I(), self.I(), jdop, JournalInternalOp);
        assert JC.NextStep(old_self.I(), self.I(), jdop, JournalInternalOp, JC.NoOpStep);
      }
    }
    method finishLoadingSuperblockPhase(inout old_self: Committer) returns (self: Committer)
      requires old_self.Inv()
      requires old_self.status.StatusLoadingSuperblock?
      requires old_self.superblock1.SuperblockSuccess?
      requires old_self.superblock2.SuperblockSuccess?
      ensures self.Inv()
      ensures JC.Next(old_self.I(), self.I(), JournalDisk.NoDiskOp, SendPersistentLocOp(self.superblock.indirectionTableLoc))
      decreases this, old_self
    {
      self := old_self;
      var idx: uint64 := if JC.increments1(self.superblock1.value.counter, self.superblock2.value.counter) then 1 else 0;
      var sup: Superblock := if idx == 1 then self.superblock2.value else self.superblock1.value;
      var _inout_tmp_0: uint64 := idx;
      self := self.(whichSuperblock := _inout_tmp_0);
      var _inout_tmp_1: Superblock := sup;
      self := self.(superblock := _inout_tmp_1);
      var _inout_tmp_2: Status := StatusLoadingOther;
      self := self.(status := _inout_tmp_2);
      var _inout_tmp_3: Option<uint64> := None;
      self := self.(journalFrontRead := _inout_tmp_3);
      var _inout_tmp_4: Option<uint64> := None;
      self := self.(journalBackRead := _inout_tmp_4);
      ghost var vop: VOp := SendPersistentLocOp(self.superblock.indirectionTableLoc);
      assert JC.FinishLoadingSuperblockPhase(old_self.I(), self.I(), JournalDisk.NoDiskOp, vop);
      assert JC.NextStep(old_self.I(), self.I(), JournalDisk.NoDiskOp, vop, JC.FinishLoadingSuperblockPhaseStep);
    }
    method FinishLoadingOtherPhase(inout old_self: Committer) returns (self: Committer)
      requires old_self.Inv()
      requires old_self.status.StatusLoadingOther?
      requires JC.JournalFrontIntervalOfSuperblock(old_self.superblock).Some? ==> old_self.journalist.hasFront()
      requires JC.JournalBackIntervalOfSuperblock(old_self.superblock).Some? ==> old_self.journalist.hasBack()
      ensures self.Inv()
      ensures JC.Next(old_self.I(), self.I(), JournalDisk.NoDiskOp, JournalInternalOp)
      decreases this, old_self
    {
      self := old_self;
      var success: bool, _inout_tmp_9: Journalist := self.journalist.parseJournals(inout self.journalist);
      self := self.(journalist := _inout_tmp_9);
      if success {
        var _inout_tmp_0: Status := StatusReady;
        self := self.(status := _inout_tmp_0);
        var _inout_tmp_1: Option<Location> := None;
        self := self.(frozenLoc := _inout_tmp_1);
        var _inout_tmp_2: bool := false;
        self := self.(isFrozen := _inout_tmp_2);
        var _inout_tmp_3: uint64 := 0;
        self := self.(frozenJournalPosition := _inout_tmp_3);
        var _inout_tmp_4: Option<uint64> := None;
        self := self.(superblockWrite := _inout_tmp_4);
        var _inout_tmp_5: set<uint64> := {};
        self := self.(outstandingJournalWrites := _inout_tmp_5);
        var _inout_tmp_6: Option<Superblock> := None;
        self := self.(newSuperblock := _inout_tmp_6);
        var _inout_tmp_7: CommitStatus := JC.CommitNone;
        self := self.(commitStatus := _inout_tmp_7);
        var len: uint64 := self.superblock.journalLen;
        var _inout_tmp_8: Journalist;
        _inout_tmp_8 := self.journalist.setWrittenJournalLen(inout self.journalist, len);
        self := self.(journalist := _inout_tmp_8);
      } else {
        print "FinishLoadingOtherPhase: there is replay journal\n";
      }
      assert JC.JournalFrontIntervalOfSuperblock(old_self.superblock).Some? <==> old_self.journalist.hasFront();
      assert JC.JournalBackIntervalOfSuperblock(old_self.superblock).Some? <==> old_self.journalist.hasBack();
      if success {
        ghost var s: JC.Variables := old_self.I();
        ghost var fullRange: seq<JournalBlock> := if JC.JournalBackIntervalOfSuperblock(s.superblock).Some? then JournalRanges.JournalRangeConcat(s.journalFront.value, s.journalBack.value) else if JC.JournalFrontIntervalOfSuperblock(s.superblock).Some? then s.journalFront.value else JournalRanges.JournalRangeEmpty();
        ghost var jm: JournalistImpl.Journalist := old_self.journalist;
        assert fullRange == (if jm.I().journalFront.Some? then jm.I().journalFront.value else []) + if jm.I().journalBack.Some? then jm.I().journalBack.value else [];
        assert JC.FinishLoadingOtherPhase(old_self.I(), self.I(), JournalDisk.NoDiskOp, JournalInternalOp);
        assert JC.NextStep(old_self.I(), self.I(), JournalDisk.NoDiskOp, JournalInternalOp, JC.FinishLoadingOtherPhaseStep);
      } else {
        assert JC.NoOp(old_self.I(), self.I(), JournalDisk.NoDiskOp, JournalInternalOp);
        assert JC.NextStep(old_self.I(), self.I(), JournalDisk.NoDiskOp, JournalInternalOp, JC.NoOpStep);
      }
    }
    function method isReplayEmpty(): (b: bool)
      requires journalist.Inv()
      decreases this
    {
      journalist.isReplayEmpty()
    }
    method PageInJournalReqFront(inout old_self: Committer, io: DiskIOHandler) returns (self: Committer)
      requires old_self.WF()
      requires old_self.status.StatusLoadingOther?
      requires old_self.superblock.journalLen > 0
      requires io.initialized()
      requires old_self.journalFrontRead.None?
      requires old_self.I().journalFront.None?
      modifies io
      ensures self.WF()
      ensures var dop: D.DiskOp := diskOp(IIO(io)); ValidDiskOp(dop) && IDiskOp(dop).bdop.NoDiskOp? && JC.Next(old_self.I(), self.I(), IDiskOp(dop).jdop, JournalInternalOp)
      decreases this, old_self, io
    {
      self := old_self;
      var len: uint64 := if self.superblock.journalStart + self.superblock.journalLen >= NumJournalBlocks() then NumJournalBlocks() - self.superblock.journalStart else self.superblock.journalLen;
      var loc: Location := JournalRangeLocation(self.superblock.journalStart, len);
      var id: D.ReqId := RequestRead(io, loc);
      var _inout_tmp_0: Option<uint64> := Some(id);
      self := self.(journalFrontRead := _inout_tmp_0);
      var _inout_tmp_1: Option<uint64> := if self.journalBackRead == Some(id) then None else self.journalBackRead;
      self := self.(journalBackRead := _inout_tmp_1);
      ghost var jdop: JournalDisk.DiskOp := IDiskOp(diskOp(IIO(io))).jdop;
      assert JC.PageInJournalReq(old_self.I(), self.I(), jdop, JournalInternalOp, 0);
      assert JC.NextStep(old_self.I(), self.I(), jdop, JournalInternalOp, JC.PageInJournalReqStep(0));
    }
    method PageInJournalReqBack(inout old_self: Committer, io: DiskIOHandler) returns (self: Committer)
      requires old_self.WF()
      requires old_self.status.StatusLoadingOther?
      requires old_self.superblock.journalLen > 0
      requires old_self.superblock.journalStart + old_self.superblock.journalLen > NumJournalBlocks()
      requires io.initialized()
      requires old_self.journalBackRead.None?
      requires old_self.I().journalBack.None?
      modifies io
      ensures self.WF()
      ensures var dop: D.DiskOp := diskOp(IIO(io)); ValidDiskOp(dop) && IDiskOp(dop).bdop.NoDiskOp? && JC.Next(old_self.I(), self.I(), IDiskOp(dop).jdop, JournalInternalOp)
      decreases this, old_self, io
    {
      self := old_self;
      var len: uint64 := self.superblock.journalStart + self.superblock.journalLen - NumJournalBlocks();
      var loc: Location := JournalRangeLocation(0, len);
      var id: D.ReqId := RequestRead(io, loc);
      var _inout_tmp_0: Option<uint64> := Some(id);
      self := self.(journalBackRead := _inout_tmp_0);
      var _inout_tmp_1: Option<uint64> := if self.journalFrontRead == Some(id) then None else self.journalFrontRead;
      self := self.(journalFrontRead := _inout_tmp_1);
      ghost var jdop: JournalDisk.DiskOp := IDiskOp(diskOp(IIO(io))).jdop;
      assert JC.PageInJournalReq(old_self.I(), self.I(), jdop, JournalInternalOp, 1);
      assert JC.NextStep(old_self.I(), self.I(), jdop, JournalInternalOp, JC.PageInJournalReqStep(1));
    }
    method pageInJournalResp(inout old_self: Committer, io: DiskIOHandler) returns (self: Committer)
      requires old_self.WF()
      requires old_self.status.StatusLoadingOther?
      requires io.diskOp().RespReadOp?
      requires ValidDiskOp(io.diskOp())
      requires ValidJournalLocation(LocOfRespRead(io.diskOp().respRead))
      ensures self.WF()
      ensures var dop: D.DiskOp := diskOp(IIO(io)); ValidDiskOp(dop) && IDiskOp(dop).bdop.NoDiskOp? && JC.Next(old_self.I(), self.I(), IDiskOp(dop).jdop, JournalInternalOp)
      decreases this, old_self, io
    {
      self := old_self;
      var id: D.ReqId, addr: uint64, bytes: seq<byte> := io.getReadResult();
      var jr: Option<JournalRange> := JournalistParsingImpl.computeJournalRangeOfByteSeq(bytes);
      ghost var jdop: JournalDisk.DiskOp := IDiskOp(diskOp(IIO(io))).jdop;
      if jr.Some? {
        assert |jr.value| <= NumJournalBlocks() as int by {
          reveal_ValidJournalLocation();
        }
        if self.journalFrontRead == Some(id) {
          var _inout_tmp_0: Journalist;
          _inout_tmp_0 := self.journalist.setFront(inout self.journalist, jr.value);
          self := self.(journalist := _inout_tmp_0);
          var _inout_tmp_1: Option<uint64> := None;
          self := self.(journalFrontRead := _inout_tmp_1);
          assert JC.PageInJournalResp(old_self.I(), self.I(), jdop, JournalInternalOp, 0);
          assert JC.NextStep(old_self.I(), self.I(), jdop, JournalInternalOp, JC.PageInJournalRespStep(0));
        } else if self.journalBackRead == Some(id) {
          var _inout_tmp_2: Journalist;
          _inout_tmp_2 := self.journalist.setBack(inout self.journalist, jr.value);
          self := self.(journalist := _inout_tmp_2);
          var _inout_tmp_3: Option<uint64> := None;
          self := self.(journalBackRead := _inout_tmp_3);
          assert JC.PageInJournalResp(old_self.I(), self.I(), jdop, JournalInternalOp, 1);
          assert JC.NextStep(old_self.I(), self.I(), jdop, JournalInternalOp, JC.PageInJournalRespStep(1));
        } else {
          assert JC.NoOp(old_self.I(), self.I(), jdop, JournalInternalOp);
          assert JC.NextStep(old_self.I(), self.I(), jdop, JournalInternalOp, JC.NoOpStep);
        }
      } else {
        assert JC.NoOp(old_self.I(), self.I(), jdop, JournalInternalOp);
        assert JC.NextStep(old_self.I(), self.I(), jdop, JournalInternalOp, JC.NoOpStep);
      }
    }
    method tryFinishLoadingOtherPhase(inout old_self: Committer, io: DiskIOHandler) returns (self: Committer)
      requires old_self.Inv()
      requires old_self.status.StatusLoadingOther?
      requires io.initialized()
      modifies io
      ensures self.WF()
      ensures var dop: D.DiskOp := diskOp(IIO(io)); ValidDiskOp(dop) && IDiskOp(dop).bdop.NoDiskOp? && JC.Next(old_self.I(), self.I(), IDiskOp(dop).jdop, JournalInternalOp)
      decreases this, old_self, io
    {
      self := old_self;
      var hasFront: bool := self.journalist.hasFront();
      var hasBack: bool := self.journalist.hasBack();
      if self.superblock.journalLen > 0 && !self.journalFrontRead.Some? && !hasFront {
        var _inout_tmp_0: Committer;
        _inout_tmp_0 := self.PageInJournalReqFront(inout self, io);
        self := _inout_tmp_0;
      } else if self.superblock.journalStart + self.superblock.journalLen > NumJournalBlocks() && !self.journalBackRead.Some? && !hasBack {
        var _inout_tmp_1: Committer;
        _inout_tmp_1 := self.PageInJournalReqBack(inout self, io);
        self := _inout_tmp_1;
      } else if (self.superblock.journalLen > 0 ==> hasFront) && (self.superblock.journalStart + self.superblock.journalLen > NumJournalBlocks() ==> hasBack) {
        var _inout_tmp_2: Committer;
        _inout_tmp_2 := self.FinishLoadingOtherPhase(inout self);
        self := _inout_tmp_2;
      } else {
        ghost var jdop: JournalDisk.DiskOp := IDiskOp(diskOp(IIO(io))).jdop;
        assert JC.NoOp(old_self.I(), self.I(), jdop, JournalInternalOp);
        assert JC.NextStep(old_self.I(), self.I(), jdop, JournalInternalOp, JC.NoOpStep);
      }
    }
    static function method start_pos_add(a: uint64, b: uint64): uint64
      requires 0 <= a <= NumJournalBlocks()
      requires 0 <= b <= NumJournalBlocks()
      decreases a, b
    {
      if a + b >= NumJournalBlocks() then
        a + b - NumJournalBlocks()
      else
        a + b
    }
    method WriteOutJournal(inout old_self: Committer, io: DiskIOHandler) returns (self: Committer)
      requires io.initialized()
      requires old_self.Inv()
      requires old_self.journalist.I().inMemoryJournalFrozen != [] || old_self.journalist.I().inMemoryJournal != []
      requires old_self.superblockWrite.None?
      modifies io
      ensures self.WF()
      ensures var dop: D.DiskOp := diskOp(IIO(io)); ValidDiskOp(dop) && IDiskOp(dop).bdop.NoDiskOp? && JC.Next(old_self.I(), self.I(), IDiskOp(dop).jdop, JournalInternalOp)
      decreases this, old_self, io
    {
      self := old_self;
      var writtenJournalLen: uint64 := self.journalist.getWrittenJournalLen();
      var doingFrozen: bool := self.journalist.hasFrozenJournal();
      var j: seq<byte>;
      if doingFrozen {
        var _inout_tmp_0: Journalist;
        j, _inout_tmp_0 := self.journalist.packageFrozenJournal(inout self.journalist);
        self := self.(journalist := _inout_tmp_0);
      } else {
        var _inout_tmp_1: Journalist;
        j, _inout_tmp_1 := self.journalist.packageInMemoryJournal(inout self.journalist);
        self := self.(journalist := _inout_tmp_1);
      }
      var start: uint64 := start_pos_add(self.superblock.journalStart, writtenJournalLen);
      var len: uint64 := |j| as uint64 / 4096;
      var contiguous: bool := start + len <= NumJournalBlocks();
      if contiguous {
        var id: D.ReqId := io.write(JournalPoint(start), j);
        var _inout_tmp_2: set<JC.ReqId> := self.outstandingJournalWrites + {id};
        self := self.(outstandingJournalWrites := _inout_tmp_2);
      } else {
        var cut: uint64 := (NumJournalBlocks() - start) * 4096;
        var id1: D.ReqId, id2: uint64 := io.write2(JournalPoint(start), j[..cut], JournalPoint(0), j[cut..]);
        var _inout_tmp_3: set<JC.ReqId> := self.outstandingJournalWrites + {id1, id2};
        self := self.(outstandingJournalWrites := _inout_tmp_3);
      }
      if doingFrozen {
        var _inout_tmp_4: uint64 := self.journalist.getWrittenJournalLen();
        self := self.(frozenJournalPosition := _inout_tmp_4);
      } else {
        var _inout_tmp_5: LinearMutableMap.LinearHashMap<JC.SyncReqStatus>;
        _inout_tmp_5 := SyncReqs3to2(inout self.syncReqs);
        self := self.(syncReqs := _inout_tmp_5);
      }
      ghost var jr: seq<JournalBlock> := JournalRangeOfByteSeq(j).value;
      assert |jr| == len as int;
      ghost var dop: D.DiskOp := diskOp(IIO(io));
      if contiguous {
        assert LocOfReqWrite(dop.reqWrite) == JournalRangeLocation(start, len);
        assert ValidDiskOp(dop);
      } else {
        assert LocOfReqWrite(dop.reqWrite1) == JournalRangeLocation(start, NumJournalBlocks() - start);
        assert LocOfReqWrite(dop.reqWrite2) == JournalRangeLocation(0, len - (NumJournalBlocks() - start));
        JournalBytesSplit(j, len as int, NumJournalBlocks() as int - start as int);
        assert ValidDiskOp(dop);
      }
      assert JC.WriteBackJournalReq(old_self.I(), self.I(), IDiskOp(dop).jdop, JournalInternalOp, jr);
      assert JC.NextStep(old_self.I(), self.I(), IDiskOp(dop).jdop, JournalInternalOp, JC.WriteBackJournalReqStep(jr));
    }
    method writeOutSuperblockAdvanceLog(inout old_self: Committer, io: DiskIOHandler) returns (self: Committer)
      requires io.initialized()
      requires old_self.Inv()
      requires old_self.status == StatusReady
      requires old_self.commitStatus.CommitNone?
      requires old_self.outstandingJournalWrites == {}
      requires old_self.journalist.I().inMemoryJournalFrozen == []
      modifies io
      ensures self.WF()
      ensures var dop: D.DiskOp := diskOp(IIO(io)); ValidDiskOp(dop) && IDiskOp(dop).bdop.NoDiskOp? && JC.Next(old_self.I(), self.I(), IDiskOp(dop).jdop, JournalInternalOp)
      decreases this, old_self, io
    {
      self := old_self;
      var writtenJournalLen: uint64 := self.journalist.getWrittenJournalLen();
      var newSuperblock: Superblock := SectorType.Superblock(JC.IncrementSuperblockCounter(self.superblock.counter), self.superblock.journalStart, writtenJournalLen, self.superblock.indirectionTableLoc);
      assert JC.WFSuperblock(newSuperblock);
      var loc: Location := if self.whichSuperblock == 0 then Superblock2Location() else Superblock1Location();
      var id: D.ReqId := RequestWrite(io, loc, SSI.SectorSuperblock(newSuperblock));
      var _inout_tmp_0: Option<Superblock> := Some(newSuperblock);
      self := self.(newSuperblock := _inout_tmp_0);
      var _inout_tmp_1: Option<uint64> := Some(id);
      self := self.(superblockWrite := _inout_tmp_1);
      var _inout_tmp_2: CommitStatus := JC.CommitAdvanceLog;
      self := self.(commitStatus := _inout_tmp_2);
      assert ValidDiskOp(diskOp(IIO(io)));
      assert JC.WriteBackSuperblockReq_AdvanceLog(old_self.I(), self.I(), IDiskOp(diskOp(IIO(io))).jdop, JournalInternalOp);
      assert JC.NextStep(old_self.I(), self.I(), IDiskOp(diskOp(IIO(io))).jdop, JournalInternalOp, JC.WriteBackSuperblockReq_AdvanceLog_Step);
    }
    method writeOutSuperblockAdvanceLocation(inout old_self: Committer, io: DiskIOHandler) returns (self: Committer)
      requires io.initialized()
      requires old_self.Inv()
      requires old_self.status == StatusReady
      requires old_self.frozenLoc.Some?
      requires old_self.commitStatus.CommitNone?
      requires old_self.outstandingJournalWrites == {}
      requires old_self.journalist.I().inMemoryJournalFrozen == []
      modifies io
      ensures self.WF()
      ensures var dop: D.DiskOp := diskOp(IIO(io)); ValidDiskOp(dop) && IDiskOp(dop).bdop.NoDiskOp? && JC.Next(old_self.I(), self.I(), IDiskOp(dop).jdop, JournalInternalOp)
      decreases this, old_self, io
    {
      self := old_self;
      var writtenJournalLen: uint64 := self.journalist.getWrittenJournalLen();
      var newSuperblock: Superblock := SectorType.Superblock(JC.IncrementSuperblockCounter(self.superblock.counter), start_pos_add(self.superblock.journalStart, self.frozenJournalPosition), writtenJournalLen - self.frozenJournalPosition, self.frozenLoc.value);
      assert JC.WFSuperblock(newSuperblock);
      var loc: Location := if self.whichSuperblock == 0 then Superblock2Location() else Superblock1Location();
      var id: D.ReqId := RequestWrite(io, loc, SSI.SectorSuperblock(newSuperblock));
      var _inout_tmp_0: Option<Superblock> := Some(newSuperblock);
      self := self.(newSuperblock := _inout_tmp_0);
      var _inout_tmp_1: Option<uint64> := Some(id);
      self := self.(superblockWrite := _inout_tmp_1);
      var _inout_tmp_2: CommitStatus := JC.CommitAdvanceLocation;
      self := self.(commitStatus := _inout_tmp_2);
      assert ValidDiskOp(diskOp(IIO(io)));
      assert JC.WriteBackSuperblockReq_AdvanceLocation(old_self.I(), self.I(), IDiskOp(diskOp(IIO(io))).jdop, JournalInternalOp);
      assert JC.NextStep(old_self.I(), self.I(), IDiskOp(diskOp(IIO(io))).jdop, JournalInternalOp, JC.WriteBackSuperblockReq_AdvanceLocation_Step);
    }
    method freeze(inout old_self: Committer) returns (self: Committer)
      requires old_self.WF()
      requires old_self.superblockWrite.None?
      requires old_self.status == StatusReady
      requires old_self.frozenLoc != Some(old_self.superblock.indirectionTableLoc)
      requires old_self.journalist.I().replayJournal == []
      ensures self.WF()
      ensures JC.Next(old_self.I(), self.I(), JournalDisk.NoDiskOp, FreezeOp)
      decreases this, old_self
    {
      self := old_self;
      var writtenJournalLen: uint64 := self.journalist.getWrittenJournalLen();
      var _inout_tmp_0: Journalist;
      _inout_tmp_0 := self.journalist.freeze(inout self.journalist);
      self := self.(journalist := _inout_tmp_0);
      var _inout_tmp_1: Option<Location> := None;
      self := self.(frozenLoc := _inout_tmp_1);
      var _inout_tmp_2: uint64 := writtenJournalLen;
      self := self.(frozenJournalPosition := _inout_tmp_2);
      var _inout_tmp_3: bool := true;
      self := self.(isFrozen := _inout_tmp_3);
      var _inout_tmp_4: LinearMutableMap.LinearHashMap<JC.SyncReqStatus>;
      _inout_tmp_4 := SyncReqs3to2(inout self.syncReqs);
      self := self.(syncReqs := _inout_tmp_4);
      assert JC.Freeze(old_self.I(), self.I(), JournalDisk.NoDiskOp, FreezeOp);
      assert JC.NextStep(old_self.I(), self.I(), JournalDisk.NoDiskOp, FreezeOp, JC.FreezeStep);
    }
    method receiveFrozenLoc(inout old_self: Committer, loc: Location) returns (self: Committer)
      requires old_self.WF()
      requires old_self.status == StatusReady
      requires old_self.isFrozen
      requires !old_self.frozenLoc.Some?
      requires ValidIndirectionTableLocation(loc)
      ensures self.WF()
      ensures JC.Next(old_self.I(), self.I(), JournalDisk.NoDiskOp, SendFrozenLocOp(loc))
      decreases this, old_self, loc
    {
      self := old_self;
      var _inout_tmp_0: Option<Location> := Some(loc);
      self := self.(frozenLoc := _inout_tmp_0);
      assert JC.ReceiveFrozenLoc(old_self.I(), self.I(), JournalDisk.NoDiskOp, SendFrozenLocOp(loc));
      assert JC.NextStep(old_self.I(), self.I(), JournalDisk.NoDiskOp, SendFrozenLocOp(loc), JC.ReceiveFrozenLocStep);
    }
    method freeId() returns (id: uint64)
      requires syncReqs.Inv()
      ensures id != 0 ==> id !in syncReqs.contents
      decreases this
    {
      var maxId: uint64 := LinearMutableMap.MaxKey(this.syncReqs);
      if maxId == 18446744073709551615 {
        id := 0;
      } else {
        id := maxId + 1;
      }
    }
    method pushSync(inout old_self: Committer) returns (id: uint64, self: Committer)
      requires old_self.Inv()
      ensures self.WF()
      ensures JC.Next(old_self.I(), self.I(), JournalDisk.NoDiskOp, if id == 0 then JournalInternalOp else PushSyncOp(id as int))
      decreases this, old_self
    {
      self := old_self;
      id := self.freeId();
      if id != 0 && self.syncReqs.count < 2305843009213693952 {
        var _inout_tmp_0: LinearHashMap<JC.SyncReqStatus>;
        _inout_tmp_0 := LinearMutableMap.Insert(inout self.syncReqs, id, JC.State3);
        self := self.(syncReqs := _inout_tmp_0);
        assert JC.PushSyncReq(old_self.I(), self.I(), JournalDisk.NoDiskOp, PushSyncOp(id as int), id);
        assert JC.NextStep(old_self.I(), self.I(), JournalDisk.NoDiskOp, PushSyncOp(id as int), JC.PushSyncReqStep(id));
      } else {
        id := 0;
        assert JC.NoOp(old_self.I(), self.I(), JournalDisk.NoDiskOp, JournalInternalOp);
        assert JC.NextStep(old_self.I(), self.I(), JournalDisk.NoDiskOp, JournalInternalOp, JC.NoOpStep);
      }
    }
    method popSync(inout old_self: Committer, id: uint64) returns (self: Committer)
      requires old_self.Inv()
      requires id in old_self.syncReqs.contents
      requires old_self.syncReqs.contents[id] == JC.State1
      ensures self.WF()
      ensures JC.Next(old_self.I(), self.I(), JournalDisk.NoDiskOp, PopSyncOp(id as int))
      decreases this, old_self, id
    {
      self := old_self;
      var _inout_tmp_0: LinearHashMap<JC.SyncReqStatus>;
      _inout_tmp_0 := LinearMutableMap.Remove(inout self.syncReqs, id);
      self := self.(syncReqs := _inout_tmp_0);
      assert JC.PopSyncReq(old_self.I(), self.I(), JournalDisk.NoDiskOp, PopSyncOp(id as int), id);
      assert JC.NextStep(old_self.I(), self.I(), JournalDisk.NoDiskOp, PopSyncOp(id as int), JC.PopSyncReqStep(id));
    }
    method tryAdvanceLog(inout old_self: Committer, io: DiskIOHandler)
        returns (wait: bool, self: Committer)
      requires old_self.Inv()
      requires io.initialized()
      requires old_self.status == StatusReady
      modifies io
      ensures self.WF()
      ensures var dop: D.DiskOp := diskOp(IIO(io)); ValidDiskOp(dop) && IDiskOp(dop).bdop.NoDiskOp? && JC.Next(old_self.I(), self.I(), IDiskOp(dop).jdop, JournalInternalOp)
      decreases this, old_self, io
    {
      self := old_self;
      wait := false;
      var hasFrozen: bool := self.journalist.hasFrozenJournal();
      var hasInMem: bool := self.journalist.hasInMemoryJournal();
      if self.superblockWrite.None? {
        if hasFrozen || hasInMem {
          var _inout_tmp_0: Committer;
          _inout_tmp_0 := self.WriteOutJournal(inout self, io);
          self := _inout_tmp_0;
        } else if self.outstandingJournalWrites == {} {
          var _inout_tmp_1: Committer;
          _inout_tmp_1 := self.writeOutSuperblockAdvanceLog(inout self, io);
          self := _inout_tmp_1;
        } else {
          wait := true;
          assert JC.NoOp(old_self.I(), self.I(), JournalDisk.NoDiskOp, JournalInternalOp);
          assert JC.NextStep(old_self.I(), self.I(), JournalDisk.NoDiskOp, JournalInternalOp, JC.NoOpStep);
        }
      } else {
        wait := true;
        assert JC.NoOp(old_self.I(), self.I(), JournalDisk.NoDiskOp, JournalInternalOp);
        assert JC.NextStep(old_self.I(), self.I(), JournalDisk.NoDiskOp, JournalInternalOp, JC.NoOpStep);
      }
    }
    method tryAdvanceLocation(inout old_self: Committer, io: DiskIOHandler)
        returns (wait: bool, self: Committer)
      requires old_self.Inv()
      requires io.initialized()
      requires old_self.status == StatusReady
      requires old_self.frozenLoc.Some?
      modifies io
      ensures self.WF()
      ensures var dop: D.DiskOp := diskOp(IIO(io)); ValidDiskOp(dop) && IDiskOp(dop).bdop.NoDiskOp? && JC.Next(old_self.I(), self.I(), IDiskOp(dop).jdop, JournalInternalOp)
      decreases this, old_self, io
    {
      self := old_self;
      wait := false;
      var hasFrozen: bool := self.journalist.hasFrozenJournal();
      var hasInMem: bool := self.journalist.hasInMemoryJournal();
      if self.superblockWrite.None? {
        if hasFrozen || hasInMem {
          var _inout_tmp_0: Committer;
          _inout_tmp_0 := self.WriteOutJournal(inout self, io);
          self := _inout_tmp_0;
        } else if self.outstandingJournalWrites == {} {
          var _inout_tmp_1: Committer;
          _inout_tmp_1 := self.writeOutSuperblockAdvanceLocation(inout self, io);
          self := _inout_tmp_1;
        } else {
          wait := true;
          assert JC.NoOp(old_self.I(), self.I(), JournalDisk.NoDiskOp, JournalInternalOp);
          assert JC.NextStep(old_self.I(), self.I(), JournalDisk.NoDiskOp, JournalInternalOp, JC.NoOpStep);
        }
      } else {
        wait := true;
        assert JC.NoOp(old_self.I(), self.I(), JournalDisk.NoDiskOp, JournalInternalOp);
        assert JC.NextStep(old_self.I(), self.I(), JournalDisk.NoDiskOp, JournalInternalOp, JC.NoOpStep);
      }
    }
    method writeBackSuperblockResp(inout old_self: Committer, ghost io: IO) returns (self: Committer)
      requires old_self.Inv()
      requires ValidDiskOp(diskOp(io))
      requires IDiskOp(diskOp(io)).jdop.RespWriteSuperblockOp?
      requires Some(io.id) == old_self.superblockWrite
      ensures self.WF()
      ensures JC.Next(old_self.I(), self.I(), IDiskOp(diskOp(io)).jdop, if old_self.status.StatusReady? && old_self.commitStatus.CommitAdvanceLocation? then CleanUpOp else JournalInternalOp)
      decreases this, old_self, io
    {
      self := old_self;
      if self.status.StatusReady? && self.commitStatus.CommitAdvanceLocation? {
        var writtenJournalLen: uint64 := self.journalist.getWrittenJournalLen();
        var _inout_tmp_0: Option<uint64> := None;
        self := self.(superblockWrite := _inout_tmp_0);
        var _inout_tmp_1: Superblock := self.newSuperblock.value;
        self := self.(superblock := _inout_tmp_1);
        var _inout_tmp_2: Option<Superblock> := None;
        self := self.(newSuperblock := _inout_tmp_2);
        var _inout_tmp_3: uint64 := if self.whichSuperblock == 0 then 1 else 0;
        self := self.(whichSuperblock := _inout_tmp_3);
        var _inout_tmp_4: LinearMutableMap.LinearHashMap<JC.SyncReqStatus>;
        _inout_tmp_4 := SyncReqs2to1(inout self.syncReqs);
        self := self.(syncReqs := _inout_tmp_4);
        var position: uint64 := self.frozenJournalPosition;
        var _inout_tmp_5: Journalist;
        _inout_tmp_5 := self.journalist.updateWrittenJournalLen(inout self.journalist, writtenJournalLen - position);
        self := self.(journalist := _inout_tmp_5);
        var _inout_tmp_6: uint64 := 0;
        self := self.(frozenJournalPosition := _inout_tmp_6);
        var _inout_tmp_7: Option<Location> := None;
        self := self.(frozenLoc := _inout_tmp_7);
        var _inout_tmp_8: bool := false;
        self := self.(isFrozen := _inout_tmp_8);
        var _inout_tmp_9: CommitStatus := JC.CommitNone;
        self := self.(commitStatus := _inout_tmp_9);
        assert JC.WriteBackSuperblockResp(old_self.I(), self.I(), IDiskOp(diskOp(io)).jdop, CleanUpOp);
        assert JC.NextStep(old_self.I(), self.I(), IDiskOp(diskOp(io)).jdop, CleanUpOp, JC.WriteBackSuperblockRespStep);
      } else if self.status.StatusReady? && self.commitStatus.CommitAdvanceLog? {
        var _inout_tmp_10: Option<uint64> := None;
        self := self.(superblockWrite := _inout_tmp_10);
        var _inout_tmp_11: Superblock := self.newSuperblock.value;
        self := self.(superblock := _inout_tmp_11);
        var _inout_tmp_12: Option<Superblock> := None;
        self := self.(newSuperblock := _inout_tmp_12);
        var _inout_tmp_13: uint64 := if self.whichSuperblock == 0 then 1 else 0;
        self := self.(whichSuperblock := _inout_tmp_13);
        var _inout_tmp_14: LinearMutableMap.LinearHashMap<JC.SyncReqStatus>;
        _inout_tmp_14 := SyncReqs2to1(inout self.syncReqs);
        self := self.(syncReqs := _inout_tmp_14);
        var _inout_tmp_15: CommitStatus := JC.CommitNone;
        self := self.(commitStatus := _inout_tmp_15);
        assert JC.WriteBackSuperblockResp(old_self.I(), self.I(), IDiskOp(diskOp(io)).jdop, JournalInternalOp);
        assert JC.NextStep(old_self.I(), self.I(), IDiskOp(diskOp(io)).jdop, JournalInternalOp, JC.WriteBackSuperblockRespStep);
      } else {
        print "writeBackSuperblockResp: didn't do anything\n";
        assert JC.NoOp(old_self.I(), self.I(), IDiskOp(diskOp(io)).jdop, JournalInternalOp);
        assert JC.NextStep(old_self.I(), self.I(), IDiskOp(diskOp(io)).jdop, JournalInternalOp, JC.NoOpStep);
      }
    }
    method writeBackJournalResp(inout old_self: Committer, io: DiskIOHandler) returns (self: Committer)
      requires old_self.WF()
      requires io.diskOp().RespWriteOp?
      requires ValidJournalLocation(LocOfRespWrite(diskOp(IIO(io)).respWrite))
      requires old_self.status.StatusReady?
      ensures self.WF()
      ensures JC.Next(old_self.I(), self.I(), IDiskOp(diskOp(IIO(io))).jdop, JournalInternalOp)
      decreases this, old_self, io
    {
      self := old_self;
      var id: D.ReqId, addr: uint64, len: uint64 := io.getWriteResult();
      ghost var contained: bool := id in self.outstandingJournalWrites;
      var _inout_tmp_0: set<JC.ReqId> := self.outstandingJournalWrites - {id};
      self := self.(outstandingJournalWrites := _inout_tmp_0);
      ghost var jdop: JournalDisk.DiskOp := IDiskOp(diskOp(IIO(io))).jdop;
      if contained {
        assert JC.WriteBackJournalResp(old_self.I(), self.I(), jdop, JournalInternalOp);
        assert JC.NextStep(old_self.I(), self.I(), jdop, JournalInternalOp, JC.WriteBackJournalRespStep);
      } else {
        assert JC.NoOp(old_self.I(), self.I(), jdop, JournalInternalOp);
        assert JC.NextStep(old_self.I(), self.I(), jdop, JournalInternalOp, JC.NoOpStep);
      }
    }
    method readSuperblockResp(inout old_self: Committer, io: DiskIOHandler, which: uint64)
        returns (self: Committer)
      requires old_self.WF()
      requires io.diskOp().RespReadOp?
      requires ValidDiskOp(diskOp(IIO(io)))
      requires diskOp(IIO(io)).RespReadOp?
      requires which == 0 || which == 1
      requires which == 0 ==> LocOfRespRead(diskOp(IIO(io)).respRead) == Superblock1Location()
      requires which == 1 ==> LocOfRespRead(diskOp(IIO(io)).respRead) == Superblock2Location()
      ensures self.WF()
      ensures JC.Next(old_self.I(), self.I(), IDiskOp(diskOp(IIO(io))).jdop, JournalInternalOp)
      decreases this, old_self, io, which
    {
      self := old_self;
      var id: D.ReqId;
      var sector: lOption<SSI.Sector>;
      id, sector := IOImpl.ReadSector(io);
      var res: SuperblockReadResult := if sector.lSome? && sector.value.SectorSuperblock? then JC.SuperblockSuccess(sector.value.superblock) else JC.SuperblockCorruption;
      if which == 0 {
        if Some(id) == self.superblock1Read {
          var _inout_tmp_0: SuperblockReadResult := res;
          self := self.(superblock1 := _inout_tmp_0);
          var _inout_tmp_1: Option<uint64> := None;
          self := self.(superblock1Read := _inout_tmp_1);
        } else {
          print "readSuperblockResp did nothing\n";
        }
      } else {
        if Some(id) == self.superblock2Read {
          var _inout_tmp_2: SuperblockReadResult := res;
          self := self.(superblock2 := _inout_tmp_2);
          var _inout_tmp_3: Option<uint64> := None;
          self := self.(superblock2Read := _inout_tmp_3);
        } else {
          print "readSuperblockResp did nothing\n";
        }
      }
      match sector {
        case lSome(value) =>
          value.Free();
        case lNone() =>
          {
          }
      }
      IOModel.ReadSectorCorrect(IIO(io));
      ghost var dop: JournalDisk.DiskOp := IDiskOp(diskOp(IIO(io))).jdop;
      assert dop.RespReadSuperblockOp?;
      assert dop.which == which as int;
      if old_self.status.StatusLoadingSuperblock? && (which == 0 ==> Some(dop.id) == old_self.superblock1Read) && (which == 1 ==> Some(dop.id) == old_self.superblock2Read) {
        assert JC.PageInSuperblockResp(old_self.I(), self.I(), dop, JournalInternalOp, which as int);
        assert JC.NextStep(old_self.I(), self.I(), dop, JournalInternalOp, JC.PageInSuperblockRespStep(which as int));
      } else {
        assert JC.NoOp(old_self.I(), self.I(), dop, JournalInternalOp);
        assert JC.NextStep(old_self.I(), self.I(), dop, JournalInternalOp, JC.NoOpStep);
      }
    }
  }
  method SyncReqs2to1(inout old_m: LinearMutableMap.LinearHashMap<JC.SyncReqStatus>) returns (m: LinearMutableMap.LinearHashMap<JC.SyncReqStatus>)
    requires old_m.Inv()
    ensures m.Inv()
    ensures JC.syncReqs2to1(old_m.contents) == m.contents
    decreases old_m
  {
    m := old_m;
    var it: SimpleIterator := LinearMutableMap.SimpleIterStart(m);
    var nextOut: IteratorOutput<JC.SyncReqStatus> := LinearMutableMap.SimpleIterOutput(m, it);
    assert it.s == {};
    while !nextOut.Done?
      invariant m.Inv()
      invariant LinearMutableMap.WFSimpleIter(m, it)
      invariant nextOut == LinearMutableMap.SimpleIterOutput(m, it)
      invariant m.contents.Keys == old_m.contents.Keys
      invariant it.s <= m.contents.Keys
      invariant forall id: uint64 {:trigger old_m.contents[id]} {:trigger m.contents[id]} {:trigger id in it.s} {:trigger id in m.contents.Keys} | id in m.contents.Keys :: id in it.s ==> m.contents[id] == if old_m.contents[id] == JC.State2 then JC.State1 else old_m.contents[id]
      invariant forall id: uint64 {:trigger old_m.contents[id]} {:trigger m.contents[id]} {:trigger id in it.s} {:trigger id in m.contents.Keys} | id in m.contents.Keys :: id !in it.s ==> m.contents[id] == old_m.contents[id]
      decreases it.decreaser
    {
      ghost var keySet: set<uint64> := m.contents.Keys;
      LinearMutableMap.CountBound(m);
      var value: SyncReqStatus := if nextOut.value == JC.State2 then JC.State1 else nextOut.value;
      ghost var prev_m: LinearMutableMap.LinearHashMap<JC.SyncReqStatus> := m;
      var _inout_tmp_0: LinearHashMap<JC.SyncReqStatus>;
      _inout_tmp_0 := LinearMutableMap.UpdateByIter(inout m, it, value);
      m := _inout_tmp_0;
      assert LinearMutableMap.SimpleIterOutput(prev_m, it).key == LinearMutableMap.SimpleIterOutput(m, it).key;
      it := LinearMutableMap.SimpleIterInc(m, it);
      nextOut := LinearMutableMap.SimpleIterOutput(m, it);
    }
  }
  method SyncReqs3to2(inout old_m: LinearMutableMap.LinearHashMap<JC.SyncReqStatus>) returns (m: LinearMutableMap.LinearHashMap<JC.SyncReqStatus>)
    requires old_m.Inv()
    ensures m.Inv()
    ensures JC.syncReqs3to2(old_m.contents) == m.contents
    decreases old_m
  {
    m := old_m;
    var it: SimpleIterator := LinearMutableMap.SimpleIterStart(m);
    var nextOut: IteratorOutput<JC.SyncReqStatus> := LinearMutableMap.SimpleIterOutput(m, it);
    assert it.s == {};
    while !nextOut.Done?
      invariant m.Inv()
      invariant LinearMutableMap.WFSimpleIter(m, it)
      invariant nextOut == LinearMutableMap.SimpleIterOutput(m, it)
      invariant m.contents.Keys == old_m.contents.Keys
      invariant it.s <= m.contents.Keys
      invariant forall id: uint64 {:trigger old_m.contents[id]} {:trigger m.contents[id]} {:trigger id in it.s} {:trigger id in m.contents.Keys} | id in m.contents.Keys :: id in it.s ==> m.contents[id] == if old_m.contents[id] == JC.State3 then JC.State2 else old_m.contents[id]
      invariant forall id: uint64 {:trigger old_m.contents[id]} {:trigger m.contents[id]} {:trigger id in it.s} {:trigger id in m.contents.Keys} | id in m.contents.Keys :: id !in it.s ==> m.contents[id] == old_m.contents[id]
      decreases it.decreaser
    {
      ghost var keySet: set<uint64> := m.contents.Keys;
      LinearMutableMap.CountBound(m);
      var value: SyncReqStatus := if nextOut.value == JC.State3 then JC.State2 else nextOut.value;
      ghost var prev_m: LinearMutableMap.LinearHashMap<JC.SyncReqStatus> := m;
      var _inout_tmp_0: LinearHashMap<JC.SyncReqStatus>;
      _inout_tmp_0 := LinearMutableMap.UpdateByIter(inout m, it, value);
      m := _inout_tmp_0;
      assert LinearMutableMap.SimpleIterOutput(prev_m, it).key == LinearMutableMap.SimpleIterOutput(m, it).key;
      it := LinearMutableMap.SimpleIterInc(m, it);
      nextOut := LinearMutableMap.SimpleIterOutput(m, it);
    }
  }
}
Dafny program verifier did not attempt verification