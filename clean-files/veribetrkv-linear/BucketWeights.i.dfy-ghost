// BucketWeights.i.dfy
module BucketWeights {
  function WeightKey(key: Key): (w: nat)
    ensures w >= 0
    decreases key
  {
    4 + |key|
  }
  function WeightMessage(msg: Message): (w: nat)
    ensures w >= 0
    decreases msg
  {
    match msg {
      case Define(value) =>
        4 + ValueType.Len(value)
      case Update(delta) =>
        0
    }
  }
  function {:opaque} {:fuel 0, 0} WeightKeyMultiset(keys: multiset<Key>): (result: nat)
    ensures |keys| == 0 ==> result == 0
    decreases keys
  {
    ghost var weights: multiset<nat> := MSets.Apply(WeightKey, keys);
    assert |keys| == 0 ==> |weights| == 0;
    MSets.FoldSimple<nat>(0, MSets.AddNat, weights)
  }
  function {:opaque} {:fuel 0, 0} WeightMessageMultiset(msgs: multiset<Message>): (result: nat)
    ensures |msgs| == 0 ==> result == 0
    decreases msgs
  {
    ghost var weights: multiset<nat> := MSets.Apply(WeightMessage, msgs);
    assert |msgs| == 0 ==> |weights| == 0;
    MSets.FoldSimple<nat>(0, MSets.AddNat, weights)
  }
  function WeightKeyList(keys: seq<Key>): (result: nat)
    ensures |keys| == 0 ==> result == 0
    decreases keys
  {
    WeightKeyMultiset(multiset(keys))
  }
  function WeightMessageList(msgs: seq<Message>): (result: nat)
    ensures |msgs| == 0 ==> result == 0
    decreases msgs
  {
    WeightMessageMultiset(multiset(msgs))
  }
  function WeightBucket(bucket: Bucket): (w: nat)
    ensures |bucket.keys| == |bucket.msgs| == 0 ==> WeightBucket(bucket) == 0
    decreases bucket
  {
    WeightKeyList(bucket.keys) + WeightMessageList(bucket.msgs)
  }
  function {:opaque} {:fuel 0, 0} WeightBucketList(buckets: BucketList): (w: nat)
    decreases buckets
  {
    if |buckets| == 0 then
      0
    else
      WeightBucketList(DropLast(buckets)) + WeightBucket(Last(buckets))
  }
  function {:opaque} {:fuel 0, 0} WeightBucketMap(m: BucketMap): (w: nat)
    decreases m
  {
    WeightKeyMultiset(multiset(m.Keys)) + WeightMessageMultiset(Multisets.ValueMultiset(m))
  }
  function method WeightKeyUint64(key: Key): (w: uint64)
    ensures w as int == WeightKey(key)
    decreases key
  {
    4 + |key| as uint64
  }
  function method WeightMessageUint64(msg: Message): (w: uint64)
    ensures w as int == WeightMessage(msg)
    decreases msg
  {
    match msg {
      case Define(value) =>
        4 + |value| as uint64
      case Update(delta) =>
        0
    }
  }
  lemma WeightKeyMultisetAdditive(things1: multiset<Key>, things2: multiset<Key>)
    ensures WeightKeyMultiset(things1 + things2) == WeightKeyMultiset(things1) + WeightKeyMultiset(things2)
    decreases things1, things2
  {
    ghost var weights1: multiset<nat> := MSets.Apply(WeightKey, things1);
    ghost var weights2: multiset<nat> := MSets.Apply(WeightKey, things2);
    MSets.ApplyAdditive(WeightKey, things1, things2);
    MSets.reveal_IsIdentity();
    MSets.reveal_IsAssociative();
    MSets.reveal_IsCommutative();
    MSets.FoldSimpleAdditive<nat>(0, MSets.AddNat, weights1, weights2);
    reveal_WeightKeyMultiset();
  }
  lemma WeightMessageMultisetAdditive(things1: multiset<Message>, things2: multiset<Message>)
    ensures WeightMessageMultiset(things1 + things2) == WeightMessageMultiset(things1) + WeightMessageMultiset(things2)
    decreases things1, things2
  {
    ghost var weights1: multiset<nat> := MSets.Apply(WeightMessage, things1);
    ghost var weights2: multiset<nat> := MSets.Apply(WeightMessage, things2);
    MSets.ApplyAdditive(WeightMessage, things1, things2);
    MSets.reveal_IsIdentity();
    MSets.reveal_IsAssociative();
    MSets.reveal_IsCommutative();
    MSets.FoldSimpleAdditive<nat>(0, MSets.AddNat, weights1, weights2);
    reveal_WeightMessageMultiset();
  }
  function biggestSlotIterate(buckets: seq<Bucket>, j: uint64, bestIdx: uint64, bestWeight: uint64): (res: (uint64, uint64))
    requires 0 <= bestIdx as int < |buckets|
    requires 0 <= bestWeight as int <= MaxTotalBucketWeight()
    requires 1 <= j as int <= |buckets| <= MaxNumChildren()
    requires forall i: int {:trigger buckets[i]} | 0 <= i < |buckets| :: WFBucket(buckets[i])
    requires WeightBucketList(buckets) <= MaxTotalBucketWeight()
    requires WeightBucket(buckets[bestIdx]) == bestWeight as int
    ensures 0 <= res.0 as int < |buckets|
    ensures 0 <= res.1 as int <= MaxTotalBucketWeight()
    ensures WeightBucket(buckets[res.0]) == res.1 as int
    decreases |buckets| - j as int
  {
    if j == |buckets| as uint64 then
      (bestIdx, bestWeight)
    else
      WeightBucketLeBucketList(buckets, j as int); ghost var w: uint64 := WeightBucket(buckets[j]) as uint64; if w > bestWeight then biggestSlotIterate(buckets, j + 1, j, w) else biggestSlotIterate(buckets, j + 1, bestIdx, bestWeight)
  }
  function biggestSlot(buckets: seq<Bucket>): (res: (uint64, uint64))
    requires |buckets| > 0
    requires |buckets| <= MaxNumChildren()
    requires forall i: int {:trigger buckets[i]} | 0 <= i < |buckets| :: WFBucket(buckets[i])
    requires WeightBucketList(buckets) <= MaxTotalBucketWeight()
    ensures 0 <= res.0 as int < |buckets|
    ensures 0 <= res.1 as int <= MaxTotalBucketWeight()
    ensures WeightBucket(buckets[res.0]) == res.1 as int
    decreases buckets
  {
    WeightBucketLeBucketList(buckets, 0);
    biggestSlotIterate(buckets, 1, 0, WeightBucket(buckets[0]) as uint64)
  }
  lemma  WeightKeyListFlatten(keys: seq<Key>)
    ensures WeightKeyList(keys) == FlattenLength(FlattenShape(keys)) + 4 * |keys|
    decreases keys
  {
    if |keys| == 0 {
    } else {
      WeightKeyListAdditive(DropLast(keys), [Last(keys)]);
      assert keys == DropLast(keys) + [Last(keys)];
      WeightKeyListFlatten(DropLast(keys));
      WeightKeySingleton(Last(keys));
      reveal_FlattenShape();
      reveal_FlattenLength();
    }
  }
  lemma {:induction true}  WeightMessageListFlatten(msgs: seq<Message>)
    requires EncodableMessageSeq(msgs)
    ensures WeightMessageList(msgs) == FlattenLength(FlattenShape(messageSeq_to_bytestringSeq(msgs))) + 4 * |msgs|
    decreases msgs
  {
    if |msgs| == 0 {
    } else {
      assert msgs == DropLast(msgs) + [Last(msgs)];
      messageSeq_to_bytestringSeq_Additive(DropLast(msgs), [Last(msgs)]);
      WeightMessageListAdditive(DropLast(msgs), [Last(msgs)]);
      WeightMessageSingleton(Last(msgs));
      reveal_FlattenShape();
      reveal_FlattenLength();
    }
  }
  lemma WeightBucketEmpty()
    ensures WeightBucket(EmptyBucket()) == 0
  {
  }
  lemma WeightKeySingleton(key: Key)
    ensures WeightKeyMultiset(multiset{key}) == WeightKey(key)
    decreases key
  {
    MSets.ApplySingleton(WeightKey, key);
    MSets.FoldSimpleSingleton<nat>(0, MSets.AddNat, WeightKey(key));
    reveal_WeightKeyMultiset();
  }
  lemma WeightMessageSingleton(msg: Message)
    ensures WeightMessageMultiset(multiset{msg}) == WeightMessage(msg)
    decreases msg
  {
    MSets.ApplySingleton(WeightMessage, msg);
    MSets.FoldSimpleSingleton<nat>(0, MSets.AddNat, WeightMessage(msg));
    reveal_WeightMessageMultiset();
  }
  lemma WeightBucketSingleton(key: Key, msg: Message)
    ensures WeightBucket(SingletonBucket(key, msg)) == WeightKey(key) + WeightMessage(msg)
    decreases key, msg
  {
    WeightKeySingleton(key);
    WeightMessageSingleton(msg);
  }
  lemma Weight_BucketMap_le_Bucket(b: Bucket)
    requires PreWFBucket(b)
    ensures WeightBucketMap(b.as_map()) <= WeightBucket(b)
    decreases b
  {
    ghost var m: map<Key, Message> := b.as_map();
    MapSeqs.lemma_multisets_le(b.keys, b.msgs);
    assert WeightKeyMultiset(multiset(m.Keys)) <= WeightKeyMultiset(multiset(b.keys)) by {
      ghost var x: multiset<Key> := multiset(b.keys) - multiset(m.Keys);
      assert multiset(m.Keys) + x == multiset(b.keys);
      WeightKeyMultisetAdditive(multiset(m.Keys), x);
    }
    assert WeightMessageMultiset(Multisets.ValueMultiset(m)) <= WeightMessageMultiset(multiset(b.msgs)) by {
      ghost var x: multiset<Message> := multiset(b.msgs) - Multisets.ValueMultiset(m);
      assert Multisets.ValueMultiset(m) + x == multiset(b.msgs);
      WeightMessageMultisetAdditive(Multisets.ValueMultiset(m), x);
    }
    reveal_WeightBucketMap();
  }
  lemma Weight_BucketMap_eq_Bucket(b: Bucket)
    requires PreWFBucket(b)
    requires IsStrictlySorted(b.keys)
    ensures WeightBucketMap(b.as_map()) == WeightBucket(b)
    decreases b
  {
    Weight_Bucket_eq_BucketMap(b.as_map());
    B_of_as_map_sorted(b);
  }
  lemma Weight_Bucket_eq_BucketMap(m: BucketMap)
    ensures WeightBucket(B(m)) == WeightBucketMap(m)
    decreases m
  {
    ghost var b: Bucket := B(m);
    assert MapSeqs.map_of_seqs(b.keys, b.msgs) == m;
    MapSeqs.lemma_multisets_eq(b.keys, b.msgs);
    reveal_WeightBucketMap();
  }
  lemma Weight_SortedBucket_le_UnsortedBucket(unsorted: Bucket, sorted: Bucket)
    requires PreWFBucket(unsorted)
    requires PreWFBucket(sorted)
    requires BucketWellMarshalled(sorted)
    requires unsorted.as_map() == sorted.as_map()
    ensures WeightBucket(sorted) <= WeightBucket(unsorted)
    decreases unsorted, sorted
  {
    calc <= {
      WeightBucket(sorted);
    <=
      {
        assert B(sorted.as_map()).as_map() == sorted.as_map();
        MapSeqs.SeqsEqOfMapsEq(sorted.keys, sorted.msgs, B(sorted.as_map()).keys, B(sorted.as_map()).msgs);
        assert sorted == B(sorted.as_map());
      }
      WeightBucket(B(sorted.as_map()));
    <=
      {
        Weight_Bucket_eq_BucketMap(sorted.as_map());
      }
      WeightBucketMap(sorted.as_map());
    <=
      {
        Weight_BucketMap_le_Bucket(unsorted);
      }
      WeightBucket(unsorted);
    }
  }
  lemma WeightBucketMapSubsetLe(smaller: BucketMap, larger: BucketMap)
    requires smaller.Keys <= larger.Keys
    requires forall k: seq<NativeTypes.byte> {:trigger larger[k]} {:trigger smaller[k]} {:trigger k in smaller.Keys} | k in smaller.Keys :: smaller[k] == larger[k]
    ensures WeightBucketMap(smaller) <= WeightBucketMap(larger)
    decreases smaller, larger
  {
    calc <= {
      WeightKeyMultiset(multiset(smaller.Keys));
    <=
      {
        assert multiset(larger.Keys) == multiset(smaller.Keys) + (multiset(larger.Keys) - multiset(smaller.Keys));
        WeightKeyMultisetAdditive(multiset(smaller.Keys), multiset(larger.Keys) - multiset(smaller.Keys));
      }
      WeightKeyMultiset(multiset(larger.Keys));
    }
    calc <= {
      WeightMessageMultiset(Multisets.ValueMultiset(smaller));
    <=
      {
        calc <= {
          Multisets.ValueMultiset(smaller);
        <=
          {
            MSets.ApplyEquivalentFns(MSets.ValueMultisetFn(smaller), MSets.ValueMultisetFn(larger), multiset(smaller.Keys));
          }
          MSets.Apply(MSets.ValueMultisetFn(larger), multiset(smaller.Keys));
        <=
          {
            MSets.ApplyMonotonic(MSets.ValueMultisetFn(larger), multiset(smaller.Keys), multiset(larger.Keys));
          }
          MSets.Apply(MSets.ValueMultisetFn(larger), multiset(larger.Keys));
        <=
          Multisets.ValueMultiset(larger);
        }
        assert Multisets.ValueMultiset(larger) == Multisets.ValueMultiset(smaller) + (Multisets.ValueMultiset(larger) - Multisets.ValueMultiset(smaller));
        WeightMessageMultisetAdditive(Multisets.ValueMultiset(smaller), Multisets.ValueMultiset(larger) - Multisets.ValueMultiset(smaller));
      }
      WeightMessageMultiset(Multisets.ValueMultiset(larger));
    }
    reveal_WeightBucketMap();
  }
  lemma WeightBucketInduct(bucket: BucketMap, key: Key, msg: Message)
    requires key !in bucket
    ensures WeightBucketMap(bucket[key := msg]) == WeightBucketMap(bucket) + WeightKey(key) + WeightMessage(msg)
    decreases bucket, key, msg
  {
    calc == {
      WeightKeyMultiset(multiset(bucket[key := msg].Keys));
    ==
      {
        calc == {
          multiset(bucket[key := msg].Keys);
        ==
          multiset(bucket.Keys) + multiset{key};
        }
        WeightKeyMultisetAdditive(multiset(bucket.Keys), multiset{key});
        WeightKeySingleton(key);
      }
      WeightKeyMultiset(multiset(bucket.Keys)) + WeightKey(key);
    }
    calc == {
      WeightMessageMultiset(Multisets.ValueMultiset(bucket[key := msg]));
    ==
      {
        calc == {
          Multisets.ValueMultiset(bucket[key := msg]);
        ==
          {
            Multisets.ValueMultisetInduct(bucket, key, msg);
          }
          Multisets.ValueMultiset(bucket) + multiset{msg};
        }
        WeightMessageMultisetAdditive(Multisets.ValueMultiset(bucket), multiset{msg});
        WeightMessageSingleton(msg);
      }
      WeightMessageMultiset(Multisets.ValueMultiset(bucket)) + WeightMessage(msg);
    }
    reveal_WeightBucketMap();
  }
  lemma WeightSplitBucketLeft(bucket: Bucket, pivot: Key)
    requires WFBucket(bucket)
    ensures WeightBucket(SplitBucketLeft(bucket, pivot)) <= WeightBucket(bucket)
    decreases bucket, pivot
  {
    ghost var i: int := BoundedKeyspace.binarySearchIndexOfFirstKeyGte(bucket.keys, pivot);
    WeightKeyListAdditive(bucket.keys[..i], bucket.keys[i..]);
    WeightMessageListAdditive(bucket.msgs[..i], bucket.msgs[i..]);
    assert bucket.keys[..i] + bucket.keys[i..] == bucket.keys;
    assert bucket.msgs[..i] + bucket.msgs[i..] == bucket.msgs;
    reveal_SplitBucketLeft();
  }
  lemma WeightSplitBucketRight(bucket: Bucket, pivot: Key)
    requires WFBucket(bucket)
    ensures WeightBucket(SplitBucketRight(bucket, pivot)) <= WeightBucket(bucket)
    decreases bucket, pivot
  {
    ghost var i: int := BoundedKeyspace.binarySearchIndexOfFirstKeyGte(bucket.keys, pivot);
    WeightKeyListAdditive(bucket.keys[..i], bucket.keys[i..]);
    WeightMessageListAdditive(bucket.msgs[..i], bucket.msgs[i..]);
    assert bucket.keys[..i] + bucket.keys[i..] == bucket.keys;
    assert bucket.msgs[..i] + bucket.msgs[i..] == bucket.msgs;
    reveal_SplitBucketRight();
  }
  lemma WeightSplitBucketAdditive(bucket: Bucket, pivot: Key)
    requires PreWFBucket(bucket)
    ensures WeightBucket(SplitBucketLeft(bucket, pivot)) + WeightBucket(SplitBucketRight(bucket, pivot)) == WeightBucket(bucket)
    decreases bucket, pivot
  {
    ghost var l: Bucket := SplitBucketLeft(bucket, pivot);
    ghost var r: Bucket := SplitBucketRight(bucket, pivot);
    assert bucket.keys == l.keys + r.keys && bucket.msgs == l.msgs + r.msgs by {
      reveal_SplitBucketLeft();
      reveal_SplitBucketRight();
    }
    WeightKeyListAdditive(l.keys, r.keys);
    WeightMessageListAdditive(l.msgs, r.msgs);
  }
  lemma WeightBucketList2(a: Bucket, b: Bucket)
    ensures WeightBucketList([a, b]) == WeightBucket(a) + WeightBucket(b)
    decreases a, b
  {
    calc == {
      WeightBucketList([a, b]);
    ==
      {
        reveal_WeightBucketList();
      }
      WeightBucketList(DropLast([a, b])) + WeightBucket(Last([a, b]));
    ==
      {
        assert DropLast([a, b]) == [a];
      }
      WeightBucketList([a]) + WeightBucket(b);
    ==
      {
        reveal_WeightBucketList();
      }
      WeightBucket(a) + WeightBucket(b);
    }
  }
  lemma  WeightBucketListConcat(left: BucketList, right: BucketList)
    ensures WeightBucketList(left + right) == WeightBucketList(left) + WeightBucketList(right)
    decreases left, right
  {
    if |right| == 0 {
      reveal_WeightBucketList();
      assert left + right == left;
    } else {
      ghost var lessRight: seq<Bucket> := DropLast(right);
      calc == {
        WeightBucketList(left + right);
      ==
        {
          assert left + right == left + lessRight + [Last(right)];
        }
        WeightBucketList(left + lessRight + [Last(right)]);
      ==
        {
          reveal_WeightBucketList();
        }
        WeightBucketList(left + lessRight) + WeightBucket(Last(right));
      ==
        {
          WeightBucketListConcat(left, lessRight);
        }
        WeightBucketList(left) + WeightBucketList(lessRight) + WeightBucket(Last(right));
      ==
        {
          reveal_WeightBucketList();
        }
        WeightBucketList(left) + WeightBucketList(right);
      }
    }
  }
  lemma  WeightBucketListSlice(blist: BucketList, a: int, b: int)
    requires 0 <= a <= b <= |blist|
    ensures WeightBucketList(blist[a .. b]) <= WeightBucketList(blist)
    decreases blist, a, b
  {
    calc == {
      WeightBucketList(blist[a .. b]);
    <=
      WeightBucketList(blist[..a]) + WeightBucketList(blist[a .. b]) + WeightBucketList(blist[b..]);
    ==
      {
        WeightBucketListConcat(blist[a .. b], blist[b..]);
      }
      {
        assert blist[a .. b] + blist[b..] == blist[a..];
      }
      WeightBucketList(blist[..a]) + WeightBucketList(blist[a..]);
    ==
      {
        WeightBucketListConcat(blist[..a], blist[a..]);
      }
      {
        assert blist[..a] + blist[a..] == blist;
      }
      WeightBucketList(blist);
    }
  }
  lemma  WeightSplitBucketListLeft(blist: BucketList, pivots: PivotTable, cLeft: int, key: Key)
    requires SplitBucketListLeft.requires(blist, pivots, cLeft, key)
    ensures WeightBucketList(SplitBucketListLeft(blist, pivots, cLeft, key)) <= WeightBucketList(blist)
    decreases blist, pivots, cLeft, key
  {
    calc == {
      WeightBucketList(SplitBucketListLeft(blist, pivots, cLeft, key));
    ==
      {
        reveal_WeightBucketList();
      }
      WeightBucketList(blist[..cLeft]) + WeightBucket(SplitBucketLeft(blist[cLeft], key));
    <=
      {
        WeightSplitBucketLeft(blist[cLeft], key);
      }
      WeightBucketList(blist[..cLeft]) + WeightBucket(blist[cLeft]);
    ==
      {
        reveal_WeightBucketList();
        assert DropLast(blist[..cLeft + 1]) == blist[..cLeft];
      }
      WeightBucketList(blist[..cLeft + 1]);
    <=
      {
        WeightBucketListSlice(blist, 0, cLeft + 1);
      }
      WeightBucketList(blist);
    }
  }
  lemma  WeightSplitBucketListRight(blist: BucketList, pivots: PivotTable, cRight: int, key: Key)
    requires SplitBucketListRight.requires(blist, pivots, cRight, key)
    ensures WeightBucketList(SplitBucketListRight(blist, pivots, cRight, key)) <= WeightBucketList(blist)
    decreases blist, pivots, cRight, key
  {
    calc == {
      WeightBucketList(SplitBucketListRight(blist, pivots, cRight, key));
    ==
      WeightBucketList([SplitBucketRight(blist[cRight], key)] + blist[cRight + 1..]);
    ==
      {
        WeightBucketListConcat([SplitBucketRight(blist[cRight], key)], blist[cRight + 1..]);
      }
      WeightBucketList([SplitBucketRight(blist[cRight], key)]) + WeightBucketList(blist[cRight + 1..]);
    ==
      {
        reveal_WeightBucketList();
      }
      WeightBucket(SplitBucketRight(blist[cRight], key)) + WeightBucketList(blist[cRight + 1..]);
    <=
      {
        WeightSplitBucketRight(blist[cRight], key);
      }
      WeightBucket(blist[cRight]) + WeightBucketList(blist[cRight + 1..]);
    ==
      {
        reveal_WeightBucketList();
      }
      WeightBucketList([blist[cRight]]) + WeightBucketList(blist[cRight + 1..]);
    ==
      {
        WeightBucketListConcat([blist[cRight]], blist[cRight + 1..]);
      }
      {
        assert blist[cRight..] == [blist[cRight]] + blist[cRight + 1..];
      }
      WeightBucketList(blist[cRight..]);
    <=
      WeightBucketList(blist[..cRight]) + WeightBucketList(blist[cRight..]);
    ==
      {
        WeightBucketListConcat(blist[..cRight], blist[cRight..]);
      }
      {
        assert blist == blist[..cRight] + blist[cRight..];
      }
      WeightBucketList(blist);
    }
  }
  lemma  WeightBucketListReplace(blist: BucketList, i: int, bucket: Bucket)
    requires 0 <= i < |blist|
    ensures WeightBucketList(blist[i := bucket]) == WeightBucketList(blist) - WeightBucket(blist[i]) + WeightBucket(bucket)
    decreases blist, i, bucket
  {
    assert blist[i := bucket] == blist[..i] + [bucket] + blist[i + 1..];
    calc == {
      WeightBucketList(blist[i := bucket]);
    ==
      {
        WeightBucketListConcat(blist[..i] + [bucket], blist[i + 1..]);
      }
      WeightBucketList(blist[..i] + [bucket]) + WeightBucketList(blist[i + 1..]);
    ==
      {
        WeightBucketListConcat(blist[..i], [bucket]);
      }
      WeightBucketList(blist[..i]) + WeightBucketList([bucket]) + WeightBucketList(blist[i + 1..]);
    ==
      {
        reveal_WeightBucketList();
      }
      WeightBucketList(blist[..i]) + WeightBucket(bucket) + WeightBucketList(blist[i + 1..]);
    }
    assert blist == blist[..i] + [blist[i]] + blist[i + 1..];
    calc == {
      WeightBucketList(blist);
    ==
      {
        WeightBucketListConcat(blist[..i] + [blist[i]], blist[i + 1..]);
      }
      WeightBucketList(blist[..i] + [blist[i]]) + WeightBucketList(blist[i + 1..]);
    ==
      {
        WeightBucketListConcat(blist[..i], [blist[i]]);
      }
      WeightBucketList(blist[..i]) + WeightBucketList([blist[i]]) + WeightBucketList(blist[i + 1..]);
    ==
      {
        reveal_WeightBucketList();
      }
      WeightBucketList(blist[..i]) + WeightBucket(blist[i]) + WeightBucketList(blist[i + 1..]);
    }
  }
  lemma  WeightBucketListShrinkEntry(blist: BucketList, i: int, bucket: Bucket)
    requires 0 <= i < |blist|
    requires WeightBucket(bucket) <= WeightBucket(blist[i])
    ensures WeightBucketList(blist[i := bucket]) <= WeightBucketList(blist)
    decreases blist, i, bucket
  {
    WeightBucketListReplace(blist, i, bucket);
  }
  lemma  WeightSplitBucketInList(blist: BucketList, i: int, pivot: Key)
    requires 0 <= i < |blist|
    requires WFBucket(blist[i])
    ensures WeightBucketList(SplitBucketInList(blist, i, pivot)) == WeightBucketList(blist)
    decreases blist, i, pivot
  {
    assert blist == blist[..i] + [blist[i]] + blist[i + 1..];
    calc == {
      WeightBucketList(blist);
    ==
      {
        WeightBucketListConcat(blist[..i] + [blist[i]], blist[i + 1..]);
      }
      WeightBucketList(blist[..i] + [blist[i]]) + WeightBucketList(blist[i + 1..]);
    ==
      {
        WeightBucketListConcat(blist[..i], [blist[i]]);
      }
      WeightBucketList(blist[..i]) + WeightBucketList([blist[i]]) + WeightBucketList(blist[i + 1..]);
    ==
      {
        reveal_WeightBucketList();
      }
      WeightBucketList(blist[..i]) + WeightBucket(blist[i]) + WeightBucketList(blist[i + 1..]);
    }
    calc == {
      SplitBucketInList(blist, i, pivot);
    ==
      {
        reveal_SplitBucketInList();
      }
      replace1with2(blist, SplitBucketLeft(blist[i], pivot), SplitBucketRight(blist[i], pivot), i);
    ==
      {
        reveal_replace1with2();
      }
      blist[..i] + [SplitBucketLeft(blist[i], pivot), SplitBucketRight(blist[i], pivot)] + blist[i + 1..];
    }
    calc == {
      WeightBucketList(SplitBucketInList(blist, i, pivot));
    ==
      WeightBucketList(blist[..i] + [SplitBucketLeft(blist[i], pivot), SplitBucketRight(blist[i], pivot)] + blist[i + 1..]);
    ==
      {
        WeightBucketListConcat(blist[..i] + [SplitBucketLeft(blist[i], pivot), SplitBucketRight(blist[i], pivot)], blist[i + 1..]);
      }
      WeightBucketList(blist[..i] + [SplitBucketLeft(blist[i], pivot), SplitBucketRight(blist[i], pivot)]) + WeightBucketList(blist[i + 1..]);
    ==
      {
        WeightBucketListConcat(blist[..i], [SplitBucketLeft(blist[i], pivot), SplitBucketRight(blist[i], pivot)]);
      }
      WeightBucketList(blist[..i]) + WeightBucketList([SplitBucketLeft(blist[i], pivot), SplitBucketRight(blist[i], pivot)]) + WeightBucketList(blist[i + 1..]);
    }
    WeightBucketList2(SplitBucketLeft(blist[i], pivot), SplitBucketRight(blist[i], pivot));
    WeightSplitBucketAdditive(blist[i], pivot);
  }
  lemma WeightMergeBuckets(left: Bucket, right: Bucket)
    requires PreWFBucket(left)
    requires PreWFBucket(right)
    ensures WeightBucket(MergeBuckets(left, right)) <= WeightBucket(left) + WeightBucket(right)
    decreases left, right
  {
    reveal_MergeBuckets();
    ghost var merged: Bucket := MergeBuckets(left, right);
    calc <= {
      WeightKeyMultiset(multiset(merged.keys));
    <=
      {
        assert multiset(left.keys) + multiset(right.keys) == multiset(merged.keys) + (multiset(left.keys) + multiset(right.keys) - multiset(merged.keys));
        WeightKeyMultisetAdditive(multiset(merged.keys), multiset(left.keys) + multiset(right.keys) - multiset(merged.keys));
      }
      WeightKeyMultiset(multiset(left.keys) + multiset(right.keys));
    <=
      {
        WeightKeyMultisetAdditive(multiset(left.keys), multiset(right.keys));
      }
      WeightKeyMultiset(multiset(left.keys)) + WeightKeyMultiset(multiset(right.keys));
    }
    calc <= {
      WeightMessageMultiset(multiset(merged.msgs));
    <=
      {
        assert multiset(left.msgs) + multiset(right.msgs) == multiset(merged.msgs) + (multiset(left.msgs) + multiset(right.msgs) - multiset(merged.msgs));
        WeightMessageMultisetAdditive(multiset(merged.msgs), multiset(left.msgs) + multiset(right.msgs) - multiset(merged.msgs));
      }
      WeightMessageMultiset(multiset(left.msgs) + multiset(right.msgs));
    <=
      {
        WeightMessageMultisetAdditive(multiset(left.msgs), multiset(right.msgs));
      }
      WeightMessageMultiset(multiset(left.msgs)) + WeightMessageMultiset(multiset(right.msgs));
    }
  }
  lemma  WeightMergeBucketsInListLe(blist: BucketList, i: int)
    requires 0 <= i < |blist| - 1
    requires PreWFBucket(blist[i])
    requires PreWFBucket(blist[i + 1])
    ensures WeightBucketList(MergeBucketsInList(blist, i)) <= WeightBucketList(blist)
    decreases blist, i
  {
    ghost var newblist: seq<Bucket> := MergeBucketsInList(blist, i);
    calc <= {
      WeightBucketList(newblist);
    <=
      {
        assert newblist == newblist[..i] + newblist[i..];
        assert newblist[i..] == newblist[i .. i + 1] + newblist[i + 1..];
        WeightBucketListConcat(newblist[..i], newblist[i..]);
        WeightBucketListConcat(newblist[i .. i + 1], newblist[i + 1..]);
      }
      WeightBucketList(newblist[..i]) + WeightBucketList(newblist[i .. i + 1]) + WeightBucketList(newblist[i + 1..]);
    <=
      {
        reveal_WeightBucketList();
      }
      WeightBucketList(newblist[..i]) + WeightBucket(newblist[i]) + WeightBucketList(newblist[i + 1..]);
    <=
      {
        reveal_MergeBucketsInList();
        WeightMergeBuckets(blist[i], blist[i + 1]);
      }
      WeightBucketList(newblist[..i]) + WeightBucket(blist[i]) + WeightBucket(blist[i + 1]) + WeightBucketList(newblist[i + 1..]);
    <=
      {
        reveal_WeightBucketList();
      }
      WeightBucketList(newblist[..i]) + WeightBucketList(blist[i .. i + 2]) + WeightBucketList(newblist[i + 1..]);
    <=
      {
        reveal_MergeBucketsInList();
        assert blist[..i] == newblist[..i];
        assert blist[i + 2..] == newblist[i + 1..];
      }
      WeightBucketList(blist[..i]) + WeightBucketList(blist[i .. i + 2]) + WeightBucketList(blist[i + 2..]);
    <=
      {
        assert blist == blist[..i] + blist[i..];
        assert blist[i..] == blist[i .. i + 2] + blist[i + 2..];
        WeightBucketListConcat(blist[..i], blist[i..]);
        WeightBucketListConcat(blist[i .. i + 2], blist[i + 2..]);
      }
      WeightBucketList(blist);
    }
  }
  lemma  WeightBucketListSuffix(blist: BucketList, a: int)
    requires 0 <= a <= |blist|
    ensures WeightBucketList(blist[a..]) <= WeightBucketList(blist)
    decreases blist, a
  {
    WeightBucketListConcat(blist[..a], blist[a..]);
    assert blist == blist[..a] + blist[a..];
  }
  lemma KeyMultisetLeWeight(keys: multiset<Key>)
    ensures 4 * |keys| <= WeightKeyMultiset(keys)
    decreases keys
  {
    if |keys| == 0 {
    } else {
      ghost var weights: multiset<nat> := MSets.Apply(WeightKey, keys);
      ghost var key: Key :| key in keys;
      ghost var rest: multiset<Key> := keys - multiset{key};
      assert keys == rest + multiset{key};
      calc <= {
        4 * |keys|;
      <=
        4 * |rest| + 4 * |multiset{key}|;
      <=
        {
          KeyMultisetLeWeight(rest);
        }
        WeightKeyMultiset(rest) + WeightKey(key);
      <=
        {
          reveal_WeightKeyMultiset();
          MSets.ApplySingleton(WeightKey, key);
          MSets.FoldSimpleSingleton<nat>(0, MSets.AddNat, WeightKey(key));
        }
        WeightKeyMultiset(rest) + WeightKeyMultiset(multiset{key});
      <=
        {
          WeightKeyMultisetAdditive(rest, multiset{key});
        }
        WeightKeyMultiset(keys);
      }
    }
  }
  lemma NumElementsLteWeight(bucket: Bucket)
    requires PreWFBucket(bucket)
    ensures |bucket.keys| <= WeightBucket(bucket)
    decreases bucket.keys
  {
    KeyMultisetLeWeight(multiset(bucket.keys));
    SetCardinality(bucket.keys);
  }
  lemma WeightBucketListOneEmpty()
    ensures WeightBucketList([EmptyBucket()]) == 0
  {
    reveal_WeightBucketList();
    WeightBucketEmpty();
  }
  lemma  WeightBucketLeBucketList(blist: BucketList, i: int)
    requires 0 <= i < |blist|
    ensures WeightBucket(blist[i]) <= WeightBucketList(blist)
    decreases blist, i
  {
    calc == {
      WeightBucket(blist[i]);
    ==
      {
        reveal_WeightBucketList();
      }
      WeightBucketList([blist[i]]);
    ==
      {
        assert [blist[i]] == blist[i .. i + 1];
      }
      WeightBucketList(blist[i .. i + 1]);
    <=
      {
        WeightBucketListSlice(blist, i, i + 1);
      }
      WeightBucketList(blist);
    }
  }
  lemma WeightBucketInsert(bucket: Bucket, key: Key, msg: Message)
    requires PreWFBucket(bucket)
    ensures WeightBucket(BucketInsert(bucket, key, msg)) <= WeightBucket(bucket) + WeightKey(key) + WeightMessage(msg)
    decreases bucket, key, msg
  {
    ghost var mergedMsg: Message := Merge(msg, BucketGet(bucket.as_map(), key));
    if mergedMsg == IdentityMessage() {
      calc <= {
        WeightBucket(BucketInsert(bucket, key, msg));
      <=
        WeightBucket(B(MapRemove1(bucket.as_map(), key)));
      <=
        {
          Weight_Bucket_eq_BucketMap(MapRemove1(bucket.as_map(), key));
        }
        WeightBucketMap(MapRemove1(bucket.as_map(), key));
      <=
        {
          WeightBucketMapSubsetLe(MapRemove1(bucket.as_map(), key), bucket.as_map());
        }
        WeightBucketMap(bucket.as_map());
      <=
        {
          Weight_BucketMap_le_Bucket(bucket);
        }
        WeightBucket(bucket);
      <=
        WeightBucket(bucket) + WeightKey(key) + WeightMessage(msg);
      }
    } else if key !in bucket.as_map() {
      calc <= {
        WeightBucket(BucketInsert(bucket, key, msg));
      <=
        WeightBucket(B(bucket.as_map()[key := mergedMsg]));
      <=
        {
          Weight_Bucket_eq_BucketMap(bucket.as_map()[key := mergedMsg]);
        }
        WeightBucketMap(bucket.as_map()[key := mergedMsg]);
      <=
        {
          WeightBucketInduct(bucket.as_map(), key, mergedMsg);
        }
        WeightBucketMap(bucket.as_map()) + WeightKey(key) + WeightMessage(mergedMsg);
      <=
        WeightBucketMap(bucket.as_map()) + WeightKey(key) + WeightMessage(msg);
      <=
        {
          Weight_BucketMap_le_Bucket(bucket);
        }
        WeightBucket(bucket) + WeightKey(key) + WeightMessage(msg);
      }
    } else {
      ghost var m': map<Key, Message> := MapRemove1(bucket.as_map(), key);
      ghost var oldMsg: Message := bucket.as_map()[key];
      calc <= {
        WeightBucket(BucketInsert(bucket, key, msg));
      <=
        {
          assert m'[key := mergedMsg] == bucket.as_map()[key := mergedMsg];
        }
        WeightBucket(B(m'[key := mergedMsg]));
      <=
        {
          Weight_Bucket_eq_BucketMap(m'[key := mergedMsg]);
        }
        WeightBucketMap(m'[key := mergedMsg]);
      <=
        {
          WeightBucketInduct(m', key, mergedMsg);
        }
        WeightBucketMap(m') + WeightKey(key) + WeightMessage(mergedMsg);
      <=
        WeightBucketMap(m') + WeightKey(key) + WeightMessage(oldMsg) + WeightMessage(msg);
      <=
        {
          WeightBucketInduct(m', key, oldMsg);
        }
        WeightBucketMap(m'[key := oldMsg]) + WeightMessage(msg);
      <=
        {
          assert m'[key := oldMsg] == bucket.as_map();
        }
        WeightBucketMap(bucket.as_map()) + WeightMessage(msg);
      <=
        {
          Weight_BucketMap_le_Bucket(bucket);
        }
        WeightBucket(bucket) + WeightKey(key) + WeightMessage(msg);
      }
    }
  }
  lemma  WeightBucketListInsert(blist: BucketList, pivots: PivotTable, key: Key, msg: Message)
    requires WFBucketList(blist, pivots)
    requires BoundedKey(pivots, key)
    ensures WeightBucketList(BucketListInsert(blist, pivots, key, msg)) <= WeightBucketList(blist) + WeightKey(key) + WeightMessage(msg)
    decreases blist, pivots, key, msg
  {
    ghost var i: int := Route(pivots, key);
    ghost var bucket: Bucket := blist[i];
    ghost var bucket': Bucket := BucketInsert(bucket, key, msg);
    calc <= {
      WeightBucketList(BucketListInsert(blist, pivots, key, msg));
    <=
      {
        WeightBucketListReplace(blist, i, BucketInsert(bucket, key, msg));
      }
      WeightBucketList(blist) - WeightBucket(bucket) + WeightBucket(BucketInsert(bucket, key, msg));
    <=
      {
        WeightBucketInsert(bucket, key, msg);
      }
      WeightBucketList(blist) + WeightKey(key) + WeightMessage(msg);
    }
  }
  lemma WeightKeyListAdditive(a: seq<Key>, b: seq<Key>)
    ensures WeightKeyList(a) + WeightKeyList(b) == WeightKeyList(a + b)
    decreases a, b
  {
    WeightKeyMultisetAdditive(multiset(a), multiset(b));
  }
  lemma WeightMessageListAdditive(a: seq<Message>, b: seq<Message>)
    ensures WeightMessageList(a) + WeightMessageList(b) == WeightMessageList(a + b)
    decreases a, b
  {
    WeightMessageMultisetAdditive(multiset(a), multiset(b));
  }
  lemma WeightKeyListPushFront(key: Key, keys: seq<Key>)
    ensures WeightKeyList([key] + keys) == WeightKey(key) + WeightKeyList(keys)
    decreases key, keys
  {
    WeightKeyListAdditive([key], keys);
    WeightKeySingleton(key);
  }
  lemma WeightMessageListPushFront(msg: Message, msgs: seq<Message>)
    ensures WeightMessageList([msg] + msgs) == WeightMessage(msg) + WeightMessageList(msgs)
    decreases msg, msgs
  {
    WeightMessageListAdditive([msg], msgs);
    WeightMessageSingleton(msg);
  }
  lemma WeightKeyListPushBack(keys: seq<Key>, key: Key)
    ensures WeightKeyList(keys + [key]) == WeightKey(key) + WeightKeyList(keys)
    decreases keys, key
  {
    WeightKeyListAdditive(keys, [key]);
    WeightKeySingleton(key);
  }
  lemma WeightMessageListPushBack(msgs: seq<Message>, msg: Message)
    ensures WeightMessageList(msgs + [msg]) == WeightMessage(msg) + WeightMessageList(msgs)
    decreases msgs, msg
  {
    WeightMessageListAdditive(msgs, [msg]);
    WeightMessageSingleton(msg);
  }
  lemma WeightBucketMapSingleton(key: Key, msg: Message)
    ensures WeightBucketMap(map[key := msg]) == WeightKey(key) + WeightMessage(msg)
    decreases key, msg
  {
    ghost var m: map<seq<NativeTypes.byte>, Message> := map[];
    assert map[key := msg] == m[key := msg];
    calc == {
      WeightBucketMap(map[key := msg]);
    ==
      WeightBucketMap(m[key := msg]);
    ==
      {
        WeightBucketInduct(m, key, msg);
      }
      WeightBucketMap(m) + WeightKey(key) + WeightMessage(msg);
    ==
      {
        assert WeightBucketMap(map[]) == 0 by {
          reveal_WeightBucketMap();
        }
      }
      WeightKey(key) + WeightMessage(msg);
    }
  }
}
Dafny program verifier did not attempt verification