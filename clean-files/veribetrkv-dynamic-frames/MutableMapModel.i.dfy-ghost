// MutableMapModel.i.dfy
module MutableMapModel {
  datatype Slot = Slot(ghost slot: nat)
  datatype Item<V> = Empty | Entry(key: uint64, value: V) | Tombstone(key: uint64)
  datatype FixedSizeLinearHashMap<V> = FixedSizeLinearHashMap(storage: seq<Item<V>>, count: uint64, contents: map<uint64, Option<V>>)
  datatype ProbeResult<V> = ProbeResult(slotIdx: uint64, ghost startSlotIdx: uint64, ghost ghostSkips: uint64)
  datatype LinearHashMap<V> = LinearHashMap(underlying: FixedSizeLinearHashMap<V>, count: uint64, contents: map<uint64, V>)
  datatype IteratorOutput<V> = Next(key: uint64, value: V) | Done
  datatype Iterator<V> = Iterator(i: uint64, ghost s: set<uint64>, ghost decreaser: ORDINAL, next: IteratorOutput<V>)
  datatype SimpleIterator = SimpleIterator(i: uint64, ghost s: set<uint64>, ghost decreaser: ORDINAL)
  function method {:opaque} {:fuel 0, 0} lshift(a: uint64, b: uint32): uint64
    requires 0 <= b < 64
    decreases a, b
  {
    (a as bv64 << b) as uint64
  }
  function method {:opaque} {:fuel 0, 0} rshift(a: uint64, b: uint32): uint64
    requires 0 <= b < 64
    decreases a, b
  {
    (a as bv64 >> b) as uint64
  }
  function method {:opaque} {:fuel 0, 0} bitnot(a: uint64): uint64
    decreases a
  {
    (a as bv64 ^ 18446744073709551615) as uint64
  }
  function method {:opaque} {:fuel 0, 0} bitxor(a: uint64, b: uint64): uint64
    decreases a, b
  {
    (a as bv64 ^ b as bv64) as uint64
  }
  function method {:opaque} {:fuel 0, 0} hash64(k: uint64): uint64
    decreases k
  {
    var k0: uint64 := u64add(bitnot(k), lshift(k, 21));
    var k1: uint64 := bitxor(k0, rshift(k0, 24));
    var k2: uint64 := u64add(u64add(k1, lshift(k1, 3)), lshift(k1, 8));
    var k3: uint64 := bitxor(k2, rshift(k2, 14));
    var k4: uint64 := u64add(u64add(k3, lshift(k3, 2)), lshift(k3, 4));
    var k5: uint64 := bitxor(k4, rshift(k4, 28));
    var k6: uint64 := u64add(k5, lshift(k5, 31));
    k6
  }
  predicate ValidSlot(elementsLength: nat, slot: Slot)
    decreases elementsLength, slot
  {
    slot.slot < elementsLength
  }
  predicate ValidElements<V>(elements: seq<Item<V>>)
    decreases elements
  {
    true &&
    0 < |elements| < 18446744073709551616
  }
  function SlotForKey(elementsLength: nat, key: uint64): (result: Slot)
    requires 0 < elementsLength
    ensures ValidSlot(elementsLength, result)
    decreases elementsLength, key
  {
    var h: uint64 := hash64(key);
    Slot(h as nat % elementsLength)
  }
  function Uint64SlotForKey<V>(self: FixedSizeLinearHashMap<V>, key: uint64): (result: uint64)
    requires 0 < |self.storage| < 18446744073709551616
    ensures ValidSlot(|self.storage|, Slot(result as nat))
    ensures Slot(result as nat) == SlotForKey(|self.storage|, key)
    decreases self, key
  {
    var h: uint64 := hash64(key);
    h % |self.storage| as uint64
  }
  function SlotSuccessor(elementsLength: nat, slot: Slot): (nextSlot: Slot)
    requires ValidSlot(elementsLength, slot)
    ensures ValidSlot(elementsLength, nextSlot)
    decreases elementsLength, slot
  {
    Slot(if slot.slot == elementsLength - 1 then 0 else slot.slot + 1)
  }
  function KthSlotSuccessor(elementsLength: nat, slot: Slot, k: nat): (nextSlot: Slot)
    requires k >= 0
    requires ValidSlot(elementsLength, slot)
    ensures ValidSlot(elementsLength, nextSlot)
    decreases elementsLength, slot, k
  {
    if k == 0 then
      slot
    else
      SlotSuccessor(elementsLength, KthSlotSuccessor(elementsLength, slot, k - 1))
  }
  lemma  KthSlotSuccessorWrapsAround(elementsLength: nat, slot: Slot, k: nat)
    requires 0 <= k < elementsLength
    requires ValidSlot(elementsLength, slot)
    ensures if k < elementsLength - slot.slot then KthSlotSuccessor(elementsLength, slot, k).slot == slot.slot + k else KthSlotSuccessor(elementsLength, slot, k).slot == k - (elementsLength - slot.slot)
    decreases k
  {
  }
  predicate SlotIsEmpty<V>(elements: seq<Item<V>>, slot: Slot)
    requires ValidSlot(|elements|, slot)
    decreases elements, slot
  {
    elements[slot.slot].Empty?
  }
  predicate SlotIsEntry<V>(elements: seq<Item<V>>, slot: Slot)
    requires ValidSlot(|elements|, slot)
    decreases elements, slot
  {
    elements[slot.slot].Entry?
  }
  predicate SlotIsTombstone<V>(elements: seq<Item<V>>, slot: Slot)
    requires ValidSlot(|elements|, slot)
    decreases elements, slot
  {
    elements[slot.slot].Tombstone?
  }
  predicate FilledWithOtherKey<V>(elements: seq<Item<V>>, slot: Slot, excludingKey: uint64)
    requires ValidElements(elements)
    requires ValidSlot(|elements|, slot)
    decreases elements, slot, excludingKey
  {
    (SlotIsTombstone(elements, slot) && elements[slot.slot].key != excludingKey) || (SlotIsEntry(elements, slot) && elements[slot.slot].key != excludingKey)
  }
  predicate FilledWithOtherKeys<V>(elements: seq<Item<V>>, start: Slot, count: nat, excludingKey: uint64)
    requires ValidElements(elements)
    requires ValidSlot(|elements|, start)
    decreases elements, start, count, excludingKey
  {
    true &&
    forall offset: nat {:trigger KthSlotSuccessor(|elements|, start, offset)}  :: 
      offset < count ==>
        FilledWithOtherKey(elements, KthSlotSuccessor(|elements|, start, offset), excludingKey)
  }
  predicate FilledWithKey<V>(elements: seq<Item<V>>, slot: Slot, key: uint64)
    requires ValidElements(elements)
    requires ValidSlot(|elements|, slot)
    decreases elements, slot, key
  {
    (SlotIsEntry(elements, slot) || SlotIsTombstone(elements, slot)) &&
    elements[slot.slot].key == key
  }
  predicate FilledWithEntryKey<V>(elements: seq<Item<V>>, slot: Slot, key: uint64)
    requires ValidElements(elements)
    requires ValidSlot(|elements|, slot)
    decreases elements, slot, key
  {
    SlotIsEntry(elements, slot) &&
    elements[slot.slot].key == key
  }
  predicate SlotExplainsKey<V>(elements: seq<Item<V>>, skips: nat, key: uint64)
    requires ValidElements(elements)
    decreases elements, skips, key
  {
    var foundSlot: Slot := KthSlotSuccessor(|elements|, SlotForKey(|elements|, key), skips);
    ValidSlot(|elements|, foundSlot) &&
    FilledWithOtherKeys(elements, SlotForKey(|elements|, key), skips, key) &&
    FilledWithKey(elements, foundSlot, key)
  }
  predicate TwoNonEmptyValidSlotsWithSameKey<V>(elements: seq<Item<V>>, slot1: Slot, slot2: Slot)
    requires ValidElements(elements)
    decreases elements, slot1, slot2
  {
    ValidSlot(|elements|, slot1) &&
    ValidSlot(|elements|, slot2) &&
    (SlotIsEntry(elements, slot1) || SlotIsTombstone(elements, slot1)) &&
    (SlotIsEntry(elements, slot2) || SlotIsTombstone(elements, slot2)) &&
    elements[slot1.slot].key == elements[slot2.slot].key
  }
  predicate SameSlot(elementsLength: nat, slot1: Slot, slot2: Slot)
    requires ValidSlot(elementsLength, slot1)
    requires ValidSlot(elementsLength, slot2)
    decreases elementsLength, slot1, slot2
  {
    slot1 == slot2
  }
  predicate CantEquivocateStorageKey<V>(elements: seq<Item<V>>)
    requires ValidElements(elements)
    decreases elements
  {
    forall slot1: Slot, slot2: Slot {:trigger SameSlot(|elements|, slot1, slot2)} {:trigger TwoNonEmptyValidSlotsWithSameKey(elements, slot1, slot2)} :: 
      TwoNonEmptyValidSlotsWithSameKey(elements, slot1, slot2) ==>
        SameSlot(|elements|, slot1, slot2)
  }
  predicate KeyInSlotIsInContents<V>(elements: seq<Item<V>>, contents: map<uint64, Option<V>>, slot: Slot)
    requires ValidSlot(|elements|, slot)
    requires SlotIsEntry(elements, slot) || SlotIsTombstone(elements, slot)
    decreases elements, contents, slot
  {
    true &&
    var key: uint64 := elements[slot.slot].key; true && key in contents
  }
  predicate SeqMatchesContentKeys<V>(elements: seq<Item<V>>, contents: map<uint64, Option<V>>)
    requires ValidElements(elements)
    decreases elements, contents
  {
    (forall key: uint64 {:trigger key in contents} :: 
      key in contents ==>
        exists skips: nat {:trigger SlotExplainsKey(elements, skips, key)} :: 
          SlotExplainsKey(elements, skips, key)) &&
    (forall slot: Slot {:trigger KeyInSlotIsInContents(elements, contents, slot)} {:trigger SlotIsTombstone(elements, slot)} {:trigger SlotIsEntry(elements, slot)} {:trigger ValidSlot(|elements|, slot)} :: 
      ValidSlot(|elements|, slot) &&
      (SlotIsEntry(elements, slot) || SlotIsTombstone(elements, slot)) ==>
        KeyInSlotIsInContents(elements, contents, slot)) &&
    CantEquivocateStorageKey(elements)
  }
  predicate EntryInSlotMatchesContents<V>(elements: seq<Item<V>>, slot: Slot, contents: map<uint64, Option<V>>)
    requires ValidSlot(|elements|, slot)
    requires SlotIsEntry(elements, slot)
    decreases elements, slot, contents
  {
    true &&
    var item: Item<V> := elements[slot.slot]; item.key in contents && contents[item.key] == Some(item.value)
  }
  predicate TombstoneInSlotMatchesContents<V>(elements: seq<Item<V>>, slot: Slot, contents: map<uint64, Option<V>>)
    requires ValidSlot(|elements|, slot)
    requires SlotIsTombstone(elements, slot)
    decreases elements, slot, contents
  {
    true &&
    var item: Item<V> := elements[slot.slot]; item.key in contents && contents[item.key].None?
  }
  predicate EntriesMatchContentValue<V>(elements: seq<Item<V>>, contents: map<uint64, Option<V>>)
    requires ValidElements(elements)
    decreases elements, contents
  {
    forall slot: Slot {:trigger EntryInSlotMatchesContents(elements, slot, contents)} {:trigger SlotIsEntry(elements, slot)} {:trigger ValidSlot(|elements|, slot)} :: 
      ValidSlot(|elements|, slot) &&
      SlotIsEntry(elements, slot) ==>
        EntryInSlotMatchesContents(elements, slot, contents)
  }
  predicate TombstonesMatchContentValue<V>(elements: seq<Item<V>>, contents: map<uint64, Option<V>>)
    requires ValidElements(elements)
    decreases elements, contents
  {
    forall slot: Slot {:trigger TombstoneInSlotMatchesContents(elements, slot, contents)} {:trigger SlotIsTombstone(elements, slot)} {:trigger ValidSlot(|elements|, slot)} :: 
      ValidSlot(|elements|, slot) &&
      SlotIsTombstone(elements, slot) ==>
        TombstoneInSlotMatchesContents(elements, slot, contents)
  }
  predicate FixedSizeInv<V>(self: FixedSizeLinearHashMap<V>)
    decreases self
  {
    128 <= |self.storage| < 18446744073709551616 &&
    self.count as nat < 18446744073709551616 &&
    self.count as nat < |self.storage| &&
    |self.contents| == self.count as nat &&
    SeqMatchesContentKeys(self.storage, self.contents) &&
    EntriesMatchContentValue(self.storage, self.contents) &&
    TombstonesMatchContentValue(self.storage, self.contents)
  }
  function IndexSetThrough<V>(elements: seq<Item<V>>, through: nat): set<int>
    requires through <= |elements|
    decreases elements, through
  {
    set i: int {:trigger elements[i]} | 0 <= i < through && (elements[i].Entry? || elements[i].Tombstone?)
  }
  function IndexSet<V>(elements: seq<Item<V>>): set<int>
    decreases elements
  {
    IndexSetThrough(elements, |elements|)
  }
  function Count1<V>(item: Item<V>): nat
    decreases item
  {
    if item.Entry? || item.Tombstone? then
      1
    else
      0
  }
  function CountFilled<V>(view: seq<Item<V>>): (result: nat)
    decreases view
  {
    if |view| == 0 then
      0
    else
      CountFilled(view[1..]) + Count1(view[0])
  }
  lemma  CountFilledMatchesIndexSet<V>(elements: seq<Item<V>>)
    ensures CountFilled(elements) == |IndexSet(elements)|
    decreases elements
  {
    ghost var i: nat := 0;
    while i < |elements|
      invariant i <= |elements|
      invariant |IndexSetThrough(elements, i)| == CountFilled(elements[..i])
      decreases |elements| - i
    {
      ghost var j: int := i + 1;
      CountFilledAdditive(elements[..i], [elements[i]]);
      assert elements[..i] + [elements[i]] == elements[..j];
      if elements[i].Entry? || elements[i].Tombstone? {
        assert IndexSetThrough(elements, j) == IndexSetThrough(elements, i) + {i};
      } else {
        assert IndexSetThrough(elements, j) == IndexSetThrough(elements, i);
      }
      i := j;
    }
    assert elements[..i] == elements;
  }
  lemma IndexSetMatchesContents<V>(elements: seq<Item<V>>, contents: map<uint64, Option<V>>)
    requires ValidElements(elements)
    requires SeqMatchesContentKeys(elements, contents)
    ensures |IndexSet(elements)| == |contents.Keys|
    decreases elements, contents
  {
    ghost var relation: iset<(int, uint64)> := iset i: int {:trigger elements[i]} {:trigger i in IndexSet(elements)} | i in IndexSet(elements) :: (i, elements[i].key);
    ghost var setA: set<int> := IndexSet(elements);
    ghost var setB: set<uint64> := contents.Keys;
    assert forall a: nat {:trigger Slot(a)} {:trigger a in setA} | a in setA :: SlotIsEntry(elements, Slot(a)) || SlotIsTombstone(elements, Slot(a));
    assert forall a1: nat, a2: nat, b: uint64 {:trigger Slot(a2), Slot(a1), b in setB} {:trigger Slot(a2), (a1, b)} {:trigger Slot(a2), b in setB, a1 in setA} {:trigger Slot(a1), (a2, b)} {:trigger Slot(a1), b in setB, a2 in setA} {:trigger (a2, b), (a1, b) in relation} {:trigger (a2, b), a1 in setA} {:trigger (a1, b), a2 in setA} {:trigger b in setB, a2 in setA, a1 in setA} | a1 in setA && a2 in setA && b in setB && (a1, b) in relation && (a2, b) in relation :: SameSlot(|elements|, Slot(a1), Slot(a2));
    BijectivityImpliesEqualCardinality(IndexSet(elements), contents.Keys, relation);
  }
  lemma  CountFilledAdditive<V>(a: seq<Item<V>>, b: seq<Item<V>>)
    ensures CountFilled(a + b) == CountFilled(a) + CountFilled(b)
    decreases a, b
  {
    if |a| == 0 {
      assert a + b == b;
    } else {
      assert (a + b)[1..] == a[1..] + b;
    }
  }
  function ConstructorFromSize<V>(size: uint64): (self: FixedSizeLinearHashMap<V>)
    requires 128 <= size
    ensures FixedSizeInv(self)
    ensures forall slot: Slot {:trigger SlotIsEmpty(self.storage, slot)} {:trigger ValidSlot(|self.storage|, slot)} :: ValidSlot(|self.storage|, slot) ==> SlotIsEmpty(self.storage, slot)
    ensures self.contents == map[]
    ensures size as nat == |self.storage|
    decreases size
  {
    FixedSizeLinearHashMap(SeqOfLength(size as nat, Empty), 0, map[])
  }
  function ConstructorFromStorage<V>(storage: seq<Item<V>>, count: uint64): (self: FixedSizeLinearHashMap<V>)
    requires 128 <= |storage|
    ensures self.storage == storage
    ensures forall slot: Slot {:trigger slot.slot} {:trigger ValidSlot(|self.storage|, slot)} :: ValidSlot(|self.storage|, slot) ==> self.storage[slot.slot] == storage[slot.slot]
    ensures self.count == count
    ensures self.contents == map[]
    decreases storage, count
  {
    FixedSizeLinearHashMap(storage, count, map[])
  }
  function View<V>(elements: seq<Item<V>>, start: nat): (result: seq<Item<V>>)
    requires start < |elements|
    ensures |result| == |elements|
    decreases elements, start
  {
    elements[start..] + elements[..start]
  }
  lemma  ViewsHaveConsistentCounts<V>(a: seq<Item<V>>, b: seq<Item<V>>, delta: nat)
    requires delta < |a|
    requires b == View(a, delta)
    ensures CountFilled(a) == CountFilled(b)
    decreases a, b, delta
  {
    ghost var n: int := |a|;
    assert a == a[..delta] + a[delta..];
    CountFilledAdditive(a[..delta], a[delta..]);
    CountFilledAdditive(b[..n - delta], b[n - delta..]);
    assert b == b[..n - delta] + b[n - delta..];
  }
  function Uint64SlotSuccessor(elementsLength: nat, slot: uint64): (nextSlot: uint64)
    requires elementsLength < 18446744073709551616
    requires ValidSlot(elementsLength, Slot(slot as nat))
    ensures ValidSlot(elementsLength, Slot(nextSlot as nat))
    ensures Slot(nextSlot as nat) == SlotSuccessor(elementsLength, Slot(slot as nat))
    decreases elementsLength, slot
  {
    if slot == elementsLength as uint64 - 1 then
      0
    else
      slot + 1
  }
  lemma allNonEmptyImpliesCountEqStorageSize<V>(self: FixedSizeLinearHashMap<V>)
    requires FixedSizeInv(self)
    ensures (forall j: int {:trigger self.storage[j]} | 0 <= j < |self.storage| :: !self.storage[j].Empty?) ==> self.count as int == |self.storage|
    decreases self
  {
    ghost var elements: seq<Item<V>> := self.storage;
    if forall j: int {:trigger elements[j]} | 0 <= j < |elements| :: !elements[j].Empty? {
      ghost var elementIndices: set<int> := set i: int | 0 <= i < |elements|;
      assert IndexSetThrough(elements, |elements|) == elementIndices;
      CardinalityOfSetsOfSequenceIndices(elements, elementIndices);
      IndexSetMatchesContents(elements, self.contents);
    }
  }
  function {:opaque} {:fuel 0, 0} getEmptyWitness<V>(self: FixedSizeLinearHashMap<V>, i: uint64): (res: uint64)
    requires FixedSizeInv(self)
    requires 0 <= i as int <= |self.storage|
    requires forall j: uint64 {:trigger self.storage[j]} | 0 <= j < i :: !self.storage[j].Empty?
    requires self.count as int < |self.storage|
    ensures 0 <= res as int < |self.storage|
    ensures self.storage[res].Empty?
    decreases |self.storage| - i as int
  {
    allNonEmptyImpliesCountEqStorageSize(self);
    if self.storage[i].Empty? then
      i
    else
      getEmptyWitness(self, i + 1)
  }
  function ProbeIterate<V>(self: FixedSizeLinearHashMap<V>, key: uint64, slotIdx: uint64): (foundSlotIdx: uint64)
    requires FixedSizeInv(self)
    requires 0 <= slotIdx as int < |self.storage|
    ensures 0 <= foundSlotIdx as int < |self.storage|
    decreases var wit: uint64 := getEmptyWitness(self, 0); if slotIdx > wit then wit as int - slotIdx as int + |self.storage| else wit as int - slotIdx as int
  {
    if self.storage[slotIdx].Empty? || self.storage[slotIdx].key == key then
      slotIdx
    else
      ProbeIterate(self, key, Uint64SlotSuccessor(|self.storage|, slotIdx))
  }
  function {:opaque} {:fuel 0, 0} Probe<V>(self: FixedSizeLinearHashMap<V>, key: uint64): (foundSlotIdx: uint64)
    requires FixedSizeInv(self)
    requires self.count as int < |self.storage|
    ensures 0 <= foundSlotIdx as int < |self.storage|
    decreases self, key
  {
    ProbeIterate(self, key, Uint64SlotForKey(self, key))
  }
  lemma LemmaProbeResult<V>(self: FixedSizeLinearHashMap<V>, key: uint64) returns (result: ProbeResult<V>)
    requires FixedSizeInv(self)
    ensures result.slotIdx == Probe(self, key)
    ensures ValidSlot(|self.storage|, Slot(result.slotIdx as nat))
    ensures ValidSlot(|self.storage|, Slot(result.startSlotIdx as nat))
    ensures Slot(result.startSlotIdx as nat) == SlotForKey(|self.storage|, key)
    ensures 0 <= result.ghostSkips
    ensures result.slotIdx as nat == KthSlotSuccessor(|self.storage|, Slot(result.startSlotIdx as nat), result.ghostSkips as nat).slot
    ensures key in self.contents ==> SlotExplainsKey(self.storage, result.ghostSkips as nat, key)
    ensures key !in self.contents ==> FilledWithOtherKeys(self.storage, Slot(result.startSlotIdx as nat), result.ghostSkips as nat, key) && (self.storage[result.slotIdx].Empty? || (self.storage[result.slotIdx].Tombstone? && self.storage[result.slotIdx].key == key))
    ensures self.storage[result.slotIdx].Entry? ==> key in self.contents && key == self.storage[result.slotIdx].key
    ensures self.storage[result.slotIdx].Empty? ==> key !in self.contents
    decreases self, key
  {
    reveal_Probe();
    ghost var slotIdx: uint64 := Uint64SlotForKey(self, key);
    ghost var startSlotIdx: uint64 := slotIdx;
    ghost var startSlot: Slot := Slot(startSlotIdx as nat);
    ghost var viewFromStartSlot: seq<Item<V>> := View(self.storage, startSlotIdx as nat);
    ViewsHaveConsistentCounts(self.storage, viewFromStartSlot, startSlotIdx as nat);
    CountFilledMatchesIndexSet(self.storage);
    IndexSetMatchesContents(self.storage, self.contents);
    forall dist: nat {:trigger viewFromStartSlot[dist]} {:trigger KthSlotSuccessor(|self.storage|, startSlot, dist)} | dist < |self.storage|
      ensures self.storage[KthSlotSuccessor(|self.storage|, startSlot, dist).slot] == viewFromStartSlot[dist]
    {
      KthSlotSuccessorWrapsAround(|self.storage|, startSlot, dist);
    }
    ghost var skips: uint64 := 0;
    while true
      invariant skips < |self.storage| as uint64
      invariant slotIdx < |self.storage| as uint64
      invariant |self.storage| == |viewFromStartSlot|
      invariant self.storage[startSlotIdx..] + self.storage[..startSlotIdx] == viewFromStartSlot
      invariant slotIdx as nat == KthSlotSuccessor(|self.storage|, startSlot, skips as nat).slot
      invariant skips < |self.storage| as uint64 ==> self.storage[slotIdx] == viewFromStartSlot[skips]
      invariant ValidSlot(|self.storage|, KthSlotSuccessor(|self.storage|, startSlot, skips as nat))
      invariant FilledWithOtherKeys(self.storage, startSlot, skips as nat, key)
      invariant CountFilled(viewFromStartSlot[..skips]) == skips as nat
      invariant Probe(self, key) == ProbeIterate(self, key, slotIdx)
      decreases var wit: uint64 := getEmptyWitness(self, 0); if slotIdx > wit then wit as int - slotIdx as int + |self.storage| else wit as int - slotIdx as int
    {
      if self.storage[slotIdx].Empty? || (self.storage[slotIdx].Tombstone? && self.storage[slotIdx].key == key) {
        result := ProbeResult(slotIdx, startSlotIdx, skips);
        return;
      } else if self.storage[slotIdx].key == key {
        assert EntryInSlotMatchesContents(self.storage, Slot(slotIdx as nat), self.contents);
        result := ProbeResult(slotIdx, startSlotIdx, skips);
        return;
      }
      ghost var skipsBefore: uint64 := skips;
      slotIdx := Uint64SlotSuccessor(|self.storage|, slotIdx);
      skips := skips + 1;
      assert viewFromStartSlot[..skips] == viewFromStartSlot[..skipsBefore] + [viewFromStartSlot[skipsBefore]];
      CountFilledAdditive(viewFromStartSlot[..skipsBefore], [viewFromStartSlot[skipsBefore]]);
      assert Probe(self, key) == ProbeIterate(self, key, slotIdx);
      if skips == |self.storage| as uint64 {
        forall  | true
          ensures false
        {
          calc == {
            |self.storage|;
          ==
            skips as nat;
          ==
            CountFilled(viewFromStartSlot[..skips]);
          ==
            {
              assert viewFromStartSlot[..skips] == viewFromStartSlot;
            }
            CountFilled(viewFromStartSlot);
          ==
            |self.contents|;
          ==
            self.count as nat;
          <
            |self.storage|;
          }
        }
      }
    }
  }
  function {:opaque} {:fuel 0, 0} FixedSizeInsert<V>(self: FixedSizeLinearHashMap<V>, key: uint64, value: V): (res: (FixedSizeLinearHashMap<V>, Option<V>))
    requires FixedSizeInv(self)
    requires self.count as nat < |self.storage| - 1
    decreases self, key
  {
    var slotIdx: uint64 := Probe(self, key);
    var storage: seq<Item<V>> := self.storage[slotIdx as int := Entry(key, value)];
    var contents: map<uint64, Option<V>> := self.contents[key := Some(value)];
    if self.storage[slotIdx].Empty? then
      (FixedSizeLinearHashMap(storage, self.count + 1, contents), None)
    else if self.storage[slotIdx].Tombstone? then
      (FixedSizeLinearHashMap(storage, self.count, contents), None)
    else
      var replaced: Option<V> := Some(self.storage[slotIdx].value); (FixedSizeLinearHashMap(storage, self.count, contents), replaced)
  }
  lemma LemmaFixedSizeInsertResult<V>(self: FixedSizeLinearHashMap<V>, key: uint64, value: V)
    requires FixedSizeInv(self)
    requires self.count as nat < |self.storage| - 1
    ensures var (self': FixedSizeLinearHashMap<V>, replaced: Option<V>) := FixedSizeInsert(self, key, value); FixedSizeInv(self') && self'.contents == self.contents[key := Some(value)] && (key in self.contents ==> replaced == self.contents[key]) && (replaced.Some? ==> key in self.contents) && (key !in self.contents ==> replaced.None?) && |self'.storage| == |self.storage|
    decreases self, key
  {
    reveal_FixedSizeInsert();
    ghost var self': FixedSizeLinearHashMap<V> := FixedSizeInsert(self, key, value).0;
    ghost var replaced: Option<V> := FixedSizeInsert(self, key, value).1;
    ghost var probeRes: ProbeResult<V> := LemmaProbeResult(self, key);
    ghost var slotIdx: uint64 := probeRes.slotIdx;
    ghost var probeStartSlotIdx: uint64 := probeRes.startSlotIdx;
    ghost var probeSkips: uint64 := probeRes.ghostSkips;
    forall explainedKey: uint64 {:trigger explainedKey in self'.contents} | explainedKey in self'.contents
      ensures exists skips: nat {:trigger SlotExplainsKey(self'.storage, skips, explainedKey)} :: SlotExplainsKey(self'.storage, skips, explainedKey)
    {
      if key == explainedKey {
        assert SlotExplainsKey(self'.storage, probeSkips as nat, key);
      } else {
        ghost var oldSkips: nat :| SlotExplainsKey(self.storage, oldSkips, explainedKey);
        assert SlotExplainsKey(self'.storage, oldSkips, explainedKey);
      }
    }
    forall slot: Slot {:trigger slot.slot} {:trigger ValidSlot(|self'.storage|, slot)} | ValidSlot(|self'.storage|, slot) && self'.storage[slot.slot].Entry?
      ensures true && var item: Item<V> := self'.storage[slot.slot]; true && self'.contents[item.key] == Some(item.value)
    {
      ghost var item: Item<V> := self'.storage[slot.slot];
      if slot != Slot(slotIdx as nat) {
        if item.key == key {
          assert TwoNonEmptyValidSlotsWithSameKey(self'.storage, slot, Slot(slotIdx as nat));
          assert SameSlot(|self'.storage|, slot, Slot(slotIdx as nat));
          assert false;
        }
      }
    }
    forall slot: Slot {:trigger slot.slot} {:trigger ValidSlot(|self'.storage|, slot)} | ValidSlot(|self'.storage|, slot) && self'.storage[slot.slot].Tombstone?
      ensures true && var item: Item<V> := self'.storage[slot.slot]; true && self'.contents[item.key].None?
    {
      ghost var item: Item<V> := self'.storage[slot.slot];
      if slot != Slot(slotIdx as nat) {
        if item.key == key {
          assert TwoNonEmptyValidSlotsWithSameKey(self'.storage, slot, Slot(slotIdx as nat));
          assert SameSlot(|self'.storage|, slot, Slot(slotIdx as nat));
          assert false;
        }
      }
    }
  }
  function FixedSizeUpdateBySlot<V>(self: FixedSizeLinearHashMap<V>, slotIdx: uint64, value: V): FixedSizeLinearHashMap<V>
    requires 0 <= slotIdx as int < |self.storage|
    requires self.storage[slotIdx].Entry?
    decreases self, slotIdx
  {
    var storage': seq<Item<V>> := self.storage[slotIdx as int := self.storage[slotIdx].(value := value)];
    var contents': map<uint64, Option<V>> := self.contents[self.storage[slotIdx].key := Some(value)];
    FixedSizeLinearHashMap(storage', self.count, contents')
  }
  lemma FixedSizeUpdateBySlotResult<V>(self: FixedSizeLinearHashMap<V>, slotIdx: uint64, value: V)
    requires FixedSizeInv(self)
    requires 0 <= slotIdx as int < |self.storage|
    requires self.storage[slotIdx].Entry?
    ensures var self': FixedSizeLinearHashMap<V> := FixedSizeUpdateBySlot(self, slotIdx, value); true && FixedSizeInv(self')
    decreases self, slotIdx
  {
    ghost var self': FixedSizeLinearHashMap<V> := FixedSizeUpdateBySlot(self, slotIdx, value);
    ghost var key: uint64 := self.storage[slotIdx].key;
    assert EntryInSlotMatchesContents(self.storage, Slot(slotIdx as int), self.contents);
    assert key in self.contents;
    calc == {
      |self.contents|;
    ==
      |self.contents.Keys|;
    ==
      |self'.contents.Keys|;
    ==
      |self'.contents.Keys|;
    }
    forall explainedKey: uint64 {:trigger explainedKey in self'.contents} | explainedKey in self'.contents
      ensures exists skips: nat {:trigger SlotExplainsKey(self'.storage, skips, explainedKey)} :: SlotExplainsKey(self'.storage, skips, explainedKey)
    {
      ghost var oldSkips: nat :| SlotExplainsKey(self.storage, oldSkips, explainedKey);
      assert SlotExplainsKey(self'.storage, oldSkips, explainedKey);
    }
    forall slot: Slot {:trigger EntryInSlotMatchesContents(self'.storage, slot, self'.contents)} {:trigger SlotIsEntry(self'.storage, slot)} {:trigger ValidSlot(|self'.storage|, slot)} | ValidSlot(|self'.storage|, slot) && SlotIsEntry(self'.storage, slot)
      ensures EntryInSlotMatchesContents(self'.storage, slot, self'.contents)
    {
      assert EntryInSlotMatchesContents(self.storage, slot, self.contents);
      if slot.slot == slotIdx as int {
        calc == {
          self'.contents[self'.storage[slot.slot].key];
        ==
          Some(self'.storage[slot.slot].value);
        }
      } else {
        calc == {
          self'.contents[self'.storage[slot.slot].key];
        ==
          {
            assert self.storage[slot.slot].key == self'.storage[slot.slot].key;
            if self.storage[slot.slot].key == key {
              assert TwoNonEmptyValidSlotsWithSameKey(self.storage, slot, Slot(slotIdx as int));
            }
          }
          self.contents[self.storage[slot.slot].key];
        ==
          Some(self.storage[slot.slot].value);
        ==
          Some(self'.storage[slot.slot].value);
        }
      }
    }
  }
  function {:opaque} {:fuel 0, 0} FixedSizeGet<V>(self: FixedSizeLinearHashMap<V>, key: uint64): (found: Option<V>)
    requires FixedSizeInv(self)
    decreases self, key
  {
    var slotIdx: uint64 := Probe(self, key);
    if self.storage[slotIdx].Entry? then
      Some(self.storage[slotIdx].value)
    else
      None
  }
  lemma LemmaFixedSizeGetResult<V>(self: FixedSizeLinearHashMap<V>, key: uint64)
    requires FixedSizeInv(self)
    ensures var found: Option<V> := FixedSizeGet(self, key); true && if key in self.contents && self.contents[key].Some? then found == Some(self.contents[key].value) else found.None?
    decreases self, key
  {
    reveal_FixedSizeGet();
    ghost var _: ProbeResult<V> := LemmaProbeResult(self, key);
  }
  function {:opaque} {:fuel 0, 0} FixedSizeRemove<V>(self: FixedSizeLinearHashMap<V>, key: uint64): (res: (FixedSizeLinearHashMap<V>, Option<V>))
    requires FixedSizeInv(self)
    decreases self, key
  {
    var slotIdx: uint64 := Probe(self, key);
    if self.storage[slotIdx].Entry? then
      var removed: Option<V> := Some(self.storage[slotIdx].value);
      var self': FixedSizeLinearHashMap<V> := FixedSizeLinearHashMap(self.storage[slotIdx as int := Tombstone(key)], self.count, self.contents[key := None]);
      (self', removed)
    else
      (self, None)
  }
  lemma LemmaFixedSizeRemoveResult<V>(self: FixedSizeLinearHashMap<V>, key: uint64)
    requires FixedSizeInv(self)
    ensures var (self': FixedSizeLinearHashMap<V>, removed: Option<V>) := FixedSizeRemove(self, key); FixedSizeInv(self') && self'.contents == (if key in self.contents then self.contents[key := None] else self.contents) && removed == (if key in self.contents && self.contents[key].Some? then Some(self.contents[key].value) else None) && (removed.Some? <==> key in self.contents && self.contents[key].Some?) && self'.count == self.count
    decreases self, key
  {
    reveal_FixedSizeRemove();
    var (self': FixedSizeLinearHashMap<V>, removed: Option<V>) := FixedSizeRemove(self, key);
    ghost var probeRes: ProbeResult<V> := LemmaProbeResult(self, key);
    ghost var slotIdx: uint64 := probeRes.slotIdx;
    ghost var probeStartSlotIdx: uint64 := probeRes.startSlotIdx;
    ghost var probeSkips: uint64 := probeRes.ghostSkips;
    if self.storage[slotIdx].Entry? {
      forall explainedKey: uint64 {:trigger explainedKey in self'.contents} | explainedKey in self'.contents
        ensures exists skips: nat {:trigger SlotExplainsKey(self'.storage, skips, explainedKey)} :: SlotExplainsKey(self'.storage, skips, explainedKey)
      {
        if key == explainedKey {
          assert SlotExplainsKey(self'.storage, probeSkips as nat, key);
        } else {
          ghost var oldSkips: nat :| SlotExplainsKey(self.storage, oldSkips, explainedKey);
          assert SlotExplainsKey(self'.storage, oldSkips, explainedKey);
        }
      }
      forall slot: Slot {:trigger slot.slot} {:trigger ValidSlot(|self'.storage|, slot)} | ValidSlot(|self'.storage|, slot) && self'.storage[slot.slot].Entry?
        ensures true && var item: Item<V> := self'.storage[slot.slot]; true && self'.contents[item.key] == Some(item.value)
      {
        ghost var item: Item<V> := self'.storage[slot.slot];
        if slot != Slot(slotIdx as nat) {
          if item.key == key {
            assert CantEquivocateStorageKey(self'.storage);
            assert TwoNonEmptyValidSlotsWithSameKey(self'.storage, slot, Slot(slotIdx as nat));
            assert false;
          }
        }
      }
    } else {
    }
  }
  function MapFromStorage<V>(elements: seq<Item<V>>): (result: map<uint64, V>)
    decreases elements
  {
    if |elements| == 0 then
      map[]
    else
      var item: Item<V> := Last(elements); var dropLastMap: map<uint64, V> := MapFromStorage(DropLast(elements)); if item.Entry? then dropLastMap[item.key := item.value] else dropLastMap
  }
  predicate CantEquivocate<V>(elements: seq<Item<V>>)
    decreases elements
  {
    forall slot1: Slot, slot2: Slot {:trigger slot2.slot, slot1.slot} {:trigger slot2.slot, ValidSlot(|elements|, slot1)} {:trigger slot1.slot, ValidSlot(|elements|, slot2)} {:trigger ValidSlot(|elements|, slot2), ValidSlot(|elements|, slot1)} :: 
      ValidSlot(|elements|, slot1) &&
      ValidSlot(|elements|, slot2) &&
      elements[slot1.slot].Entry? &&
      elements[slot2.slot].Entry? &&
      elements[slot1.slot].key == elements[slot2.slot].key ==>
        slot1 == slot2
  }
  lemma CantEquivocateMapFromStorageKey<V>(underlying: FixedSizeLinearHashMap<V>)
    requires FixedSizeInv(underlying)
    ensures CantEquivocate(underlying.storage)
    decreases underlying
  {
    assert |underlying.storage| > 0;
    assert ValidSlot(|underlying.storage|, Slot(0));
    assert exists slot: Slot {:trigger ValidSlot(|underlying.storage|, slot)} :: ValidSlot(|underlying.storage|, slot);
    forall slot1: Slot, slot2: Slot {:trigger slot2.slot, slot1.slot} {:trigger slot2.slot, ValidSlot(|underlying.storage|, slot1)} {:trigger slot1.slot, ValidSlot(|underlying.storage|, slot2)} {:trigger ValidSlot(|underlying.storage|, slot2), ValidSlot(|underlying.storage|, slot1)} | ValidSlot(|underlying.storage|, slot1) && ValidSlot(|underlying.storage|, slot2) && underlying.storage[slot1.slot].Entry? && underlying.storage[slot2.slot].Entry? && underlying.storage[slot1.slot].key == underlying.storage[slot2.slot].key
      ensures slot1 == slot2
    {
      assert CantEquivocateStorageKey(underlying.storage);
      if underlying.storage[slot1.slot].Entry? && underlying.storage[slot2.slot].Entry? && underlying.storage[slot1.slot].key == underlying.storage[slot2.slot].key {
        assert TwoNonEmptyValidSlotsWithSameKey(underlying.storage, slot1, slot2);
        if slot1 != slot2 {
          assert false;
        }
        assert slot1 == slot2;
      } else {
        assert slot1 == slot2;
      }
    }
  }
  lemma  MapFromStorageProperties<V>(elements: seq<Item<V>>, result: map<uint64, V>)
    requires CantEquivocate(elements)
    requires MapFromStorage(elements) == result
    ensures forall slot: Slot {:trigger slot.slot} {:trigger ValidSlot(|elements|, slot)} :: (ValidSlot(|elements|, slot) && elements[slot.slot].Entry? ==> true) && (ValidSlot(|elements|, slot) && elements[slot.slot].Entry? ==> var item: Item<V> := elements[slot.slot]; item.key in result && result[item.key] == item.value)
    ensures forall key: uint64 {:trigger result[key]} {:trigger key in result} :: key in result ==> exists slot: Slot {:trigger slot.slot} {:trigger ValidSlot(|elements|, slot)} :: ValidSlot(|elements|, slot) && elements[slot.slot] == Entry(key, result[key])
    ensures forall key: uint64 {:trigger key in result} :: key !in result ==> forall slot: Slot {:trigger slot.slot} {:trigger ValidSlot(|elements|, slot)} :: ValidSlot(|elements|, slot) && elements[slot.slot].Entry? ==> elements[slot.slot].key != key
    decreases elements, result
  {
    if |elements| == 0 {
    } else if Last(elements).Entry? {
      ghost var item: Item<V> := Last(elements);
      assert elements == DropLast(elements) + [Last(elements)];
      ghost var dropLastMap: map<uint64, V> := MapFromStorage(DropLast(elements));
      MapFromStorageProperties(DropLast(elements), dropLastMap);
      forall slot: Slot {:trigger slot.slot} {:trigger ValidSlot(|elements|, slot)} | ValidSlot(|elements|, slot) && elements[slot.slot].Entry?
        ensures true && var item: Item<V> := elements[slot.slot]; item.key in result && result[item.key] == item.value
      {
        ghost var slotItem: Item<V> := elements[slot.slot];
        if item.key == elements[slot.slot].key {
          if slot.slot == |elements| - 1 {
            assert slotItem.key in result && result[slotItem.key] == slotItem.value;
          } else {
            ghost var slot: Slot := Slot(|elements| - 1);
            assert ValidSlot(|elements|, slot);
            assert false;
          }
        } else {
          assert slotItem.key in result && result[slotItem.key] == slotItem.value;
        }
      }
      forall key: uint64 {:trigger result[key]} {:trigger key in result} | key in result
        ensures exists slot: Slot {:trigger slot.slot} {:trigger ValidSlot(|elements|, slot)} :: ValidSlot(|elements|, slot) && elements[slot.slot] == Entry(key, result[key])
      {
        if key == item.key {
          ghost var slot: Slot := Slot(|elements| - 1);
          assert ValidSlot(|elements|, slot);
          assert elements[slot.slot] == Entry(key, result[key]);
        } else {
          assert exists slot: Slot {:trigger slot.slot} {:trigger ValidSlot(|elements|, slot)} :: ValidSlot(|elements|, slot) && elements[slot.slot] == Entry(key, result[key]);
        }
      }
    } else {
    }
  }
  predicate UnderlyingContentsMatchesContents<V>(underlying: FixedSizeLinearHashMap<V>, contents: map<uint64, V>)
    decreases underlying, contents
  {
    (forall key: uint64 {:trigger contents[key]} {:trigger underlying.contents[key]} {:trigger key in underlying.contents} {:trigger key in contents} :: 
      (key in contents ==>
        key in underlying.contents) &&
      (key in contents ==>
        underlying.contents[key] == Some(contents[key]))) &&
    forall key: uint64 {:trigger underlying.contents[key]} {:trigger key in underlying.contents} {:trigger key in contents} :: 
      key !in contents ==>
        key !in underlying.contents || underlying.contents[key].None?
  }
  predicate UnderlyingInv<V>(self: LinearHashMap<V>, underlying: FixedSizeLinearHashMap<V>)
    decreases self, underlying
  {
    |self.contents| == self.count as nat &&
    UnderlyingContentsMatchesContents(underlying, self.contents) &&
    FixedSizeInv(underlying) &&
    MapFromStorage(underlying.storage) == self.contents
  }
  lemma UnderlyingInvImpliesMapFromStorageMatchesContents<V>(underlying: FixedSizeLinearHashMap<V>, contents: map<uint64, V>)
    requires UnderlyingContentsMatchesContents(underlying, contents)
    requires FixedSizeInv(underlying)
    ensures MapFromStorage(underlying.storage) == contents
    decreases underlying, contents
  {
    ghost var mapFromStorage: map<uint64, V> := MapFromStorage(underlying.storage);
    CantEquivocateMapFromStorageKey(underlying);
    MapFromStorageProperties(underlying.storage, mapFromStorage);
    assert MapFromStorage(underlying.storage) == contents;
  }
  protected predicate Inv<V>(self: LinearHashMap<V>)
    ensures Inv(self) ==> |self.contents| == self.count as nat
    decreases self
  {
    UnderlyingInv(self, self.underlying) &&
    MapFromStorage(self.underlying.storage) == self.contents &&
    |self.contents| == self.count as nat &&
    self.count as nat <= 18446744073709551616 / 8
  }
  lemma CountBound<V>(self: LinearHashMap<V>)
    requires Inv(self)
    ensures self.count as int <= 18446744073709551616 / 8
    decreases self
  {
  }
  lemma RevealProtectedInv<V>(self: LinearHashMap<V>)
    requires Inv(self)
    ensures UnderlyingInv(self, self.underlying) && MapFromStorage(self.underlying.storage) == self.contents && |self.contents| == self.count as nat
    decreases self
  {
  }
  function {:opaque} {:fuel 0, 0} Constructor<V>(size: uint64): (self: LinearHashMap<V>)
    requires 128 <= size
    ensures Inv(self)
    ensures self.contents == map[]
    decreases size
  {
    var self: LinearHashMap<V> := LinearHashMap(ConstructorFromSize(size), 0, map[]);
    assert forall slot: Slot {:trigger slot.slot} {:trigger ValidSlot(|self.underlying.storage|, slot)} :: ValidSlot(|self.underlying.storage|, slot) ==> !self.underlying.storage[slot.slot].Entry?;
    UnderlyingInvImpliesMapFromStorageMatchesContents(self.underlying, self.contents);
    assert MapFromStorage(self.underlying.storage) == self.contents;
    self
  }
  lemma LemmaEntryKeyInContents<V>(self: LinearHashMap<V>, i: uint64)
    requires Inv(self)
    requires 0 <= i as int < |self.underlying.storage|
    requires self.underlying.storage[i].Entry?
    ensures self.underlying.storage[i].key in self.contents
    decreases self, i
  {
    assert EntryInSlotMatchesContents(self.underlying.storage, Slot(i as nat), self.underlying.contents);
  }
  function ReallocIterate<V>(self: LinearHashMap<V>, newUnderlying: FixedSizeLinearHashMap<V>, i: uint64): FixedSizeLinearHashMap<V>
    requires Inv(self)
    requires FixedSizeInv(newUnderlying)
    requires 0 <= i as int <= |self.underlying.storage|
    requires self.count as int < |newUnderlying.storage| - 1
    requires newUnderlying.contents.Keys <= self.contents.Keys
    decreases |self.underlying.storage| - i as int
  {
    if i as int == |self.underlying.storage| then
      newUnderlying
    else
      var item: Item<V> := self.underlying.storage[i]; var newUnderlying': FixedSizeLinearHashMap<V> := if item.Entry? then SetInclusionImpliesSmallerCardinality(newUnderlying.contents.Keys, self.contents.Keys); LemmaFixedSizeInsertResult(newUnderlying, item.key, item.value); LemmaEntryKeyInContents(self, i); FixedSizeInsert(newUnderlying, item.key, item.value).0 else newUnderlying; ReallocIterate(self, newUnderlying', i + 1)
  }
  function {:opaque} {:fuel 0, 0} ReallocInternal<V>(self: LinearHashMap<V>): (self': LinearHashMap<V>)
    requires self.count as nat < 18446744073709551616 / 8
    requires Inv(self)
    decreases self
  {
    var newSize: uint64 := (128 + self.count) * 4;
    var newUnderlying: FixedSizeLinearHashMap<V> := ReallocIterate(self, ConstructorFromSize(newSize), 0);
    self.(underlying := newUnderlying)
  }
  function Realloc<V>(self: LinearHashMap<V>): (self': LinearHashMap<V>)
    requires self.count as nat < 18446744073709551616 / 8
    requires Inv(self)
    ensures Inv(self')
    ensures self'.contents == self.contents
    ensures self'.underlying.count as nat < |self'.underlying.storage| - 2
    decreases self
  {
    var self': LinearHashMap<V> := ReallocInternal(self);
    LemmaReallocResult(self);
    self'
  }
  lemma  LemmaReallocIterateResult<V>(self: LinearHashMap<V>, newUnderlying: FixedSizeLinearHashMap<V>, i: uint64, transferredContents: map<uint64, V>, newSize: uint64)
    requires Inv(self)
    requires FixedSizeInv(newUnderlying)
    requires 0 <= i as int <= |self.underlying.storage|
    requires self.count as int < |newUnderlying.storage| - 1
    requires self.count as nat < 18446744073709551616 / 8
    requires newUnderlying.contents.Keys <= self.contents.Keys
    requires |newUnderlying.storage| == newSize as nat
    requires newSize == (128 + self.count) * 4
    requires |self.contents| == self.count as nat
    requires UnderlyingContentsMatchesContents(newUnderlying, transferredContents)
    requires MapFromStorage(self.underlying.storage[..i]) == transferredContents
    requires MapFromStorage(self.underlying.storage) == self.contents
    requires newUnderlying.count as nat <= i as nat
    requires FixedSizeInv(self.underlying)
    requires |transferredContents| == newUnderlying.count as nat
    requires transferredContents.Keys <= self.contents.Keys
    requires forall key: uint64 {:trigger key in newUnderlying.contents} :: key in newUnderlying.contents ==> exists slot: Slot {:trigger FilledWithEntryKey(self.underlying.storage, slot, key)} {:trigger ValidSlot(|self.underlying.storage|, slot)} {:trigger slot.slot} :: slot.slot < i as int && ValidSlot(|self.underlying.storage|, slot) && FilledWithEntryKey(self.underlying.storage, slot, key)
    ensures var newUnderlying': FixedSizeLinearHashMap<V> := ReallocIterate(self, newUnderlying, i); FixedSizeInv(newUnderlying') && newUnderlying'.count == self.count && UnderlyingInv(self.(underlying := newUnderlying'), newUnderlying') && newUnderlying'.count as nat < |newUnderlying'.storage| - 2
    decreases |self.underlying.storage| - i as int
  {
    if i as int == |self.underlying.storage| {
      assert i as nat == |self.underlying.storage|;
      assert self.underlying.storage[..i] == self.underlying.storage;
      assert MapFromStorage(self.underlying.storage) == transferredContents;
      UnderlyingInvImpliesMapFromStorageMatchesContents(newUnderlying, transferredContents);
      assert transferredContents == self.contents;
      assert |self.contents| == self.count as nat;
      assert forall key: uint64 {:trigger self.contents[key]} {:trigger newUnderlying.contents[key]} {:trigger key in newUnderlying.contents} {:trigger key in self.contents} :: (key in self.contents ==> key in newUnderlying.contents) && (key in self.contents ==> newUnderlying.contents[key] == Some(self.contents[key]));
      assert forall key: uint64 {:trigger newUnderlying.contents[key]} {:trigger key in newUnderlying.contents} {:trigger key in self.contents} :: key !in self.contents ==> key !in newUnderlying.contents || newUnderlying.contents[key].None?;
      ghost var self': LinearHashMap<V> := self.(underlying := newUnderlying);
      assert FixedSizeInv(newUnderlying);
      assert UnderlyingInv(self', newUnderlying);
      assert UnderlyingContentsMatchesContents(newUnderlying, self.contents);
      assert MapFromStorage(newUnderlying.storage) == self.contents;
      assert newUnderlying.count as nat < |newUnderlying.storage| - 2;
      assert self'.underlying.count as nat < |self'.underlying.storage| - 2;
      assert self'.contents == self.contents;
      assert self'.count == self.count;
      assert self'.count <= self'.underlying.count;
      assert Inv(self');
      return;
    }
    ghost var item: Item<V> := self.underlying.storage[i];
    assert self.underlying.storage[..i + 1] == self.underlying.storage[..i] + [self.underlying.storage[i]];
    ghost var newUnderlying': FixedSizeLinearHashMap<V>;
    ghost var transferredContents': map<uint64, V>;
    if item.Entry? {
      assert MapFromStorage(self.underlying.storage[..i]) == transferredContents;
      assert |transferredContents| == newUnderlying.count as nat;
      if item.key in newUnderlying.contents {
        ghost var j: uint64 :| 0 <= j < i && ValidSlot(|self.underlying.storage|, Slot(j as int)) && self.underlying.storage[Slot(j as int).slot].Entry? && self.underlying.storage[Slot(j as int).slot].key == item.key;
        assert ValidSlot(|self.underlying.storage|, Slot(i as nat));
        assert i != j;
        assert Slot(i as nat) != Slot(j as nat);
        assert self.underlying.storage[Slot(j as nat).slot].key == self.underlying.storage[Slot(i as nat).slot].key;
        CantEquivocateMapFromStorageKey(self.underlying);
        assert false;
      }
      assert item.key !in newUnderlying.contents;
      assert transferredContents.Keys <= self.contents.Keys;
      SetInclusionImpliesSmallerCardinality(transferredContents.Keys, self.contents.Keys);
      assert |transferredContents.Keys| <= |self.contents.Keys|;
      assert |transferredContents.Keys| == |transferredContents|;
      assert |self.contents.Keys| == |self.contents|;
      assert |transferredContents| <= |self.contents|;
      assert newUnderlying.count as nat < |newUnderlying.storage| - 1;
      LemmaFixedSizeInsertResult(newUnderlying, item.key, item.value);
      newUnderlying' := FixedSizeInsert(newUnderlying, item.key, item.value).0;
      transferredContents' := transferredContents[item.key := item.value];
      forall key: uint64 {:trigger key in newUnderlying'.contents} | key in newUnderlying'.contents
        ensures exists slot: Slot {:trigger ValidSlot(|self.underlying.storage|, slot)} {:trigger slot.slot} :: slot.slot < i as nat + 1 && ValidSlot(|self.underlying.storage|, slot) && self.underlying.storage[slot.slot].Entry? && self.underlying.storage[slot.slot].key == key
      {
        if key == item.key {
          assert ValidSlot(|self.underlying.storage|, Slot(i as nat));
          assert exists slot: Slot {:trigger ValidSlot(|self.underlying.storage|, slot)} {:trigger slot.slot} :: slot.slot < i as nat + 1 && ValidSlot(|self.underlying.storage|, slot) && self.underlying.storage[slot.slot].Entry? && self.underlying.storage[slot.slot].key == key;
        } else {
          assert exists slot: Slot {:trigger ValidSlot(|self.underlying.storage|, slot)} {:trigger slot.slot} :: slot.slot < i as nat + 1 && ValidSlot(|self.underlying.storage|, slot) && self.underlying.storage[slot.slot].Entry? && self.underlying.storage[slot.slot].key == key;
        }
      }
      assert |transferredContents'| == newUnderlying'.count as nat;
      assert MapFromStorage(self.underlying.storage[..i + 1]) == transferredContents';
    } else {
      newUnderlying' := newUnderlying;
      transferredContents' := transferredContents;
      assert forall key: uint64 {:trigger key in newUnderlying.contents} :: key in newUnderlying.contents ==> exists slot: Slot {:trigger ValidSlot(|self.underlying.storage|, slot)} {:trigger slot.slot} :: slot.slot < i as nat && ValidSlot(|self.underlying.storage|, slot) && self.underlying.storage[slot.slot].Entry? && self.underlying.storage[slot.slot].key == key;
      assert |transferredContents'| <= newUnderlying.count as nat;
      assert MapFromStorage(self.underlying.storage[..i + 1]) == transferredContents';
    }
    assert MapFromStorage(self.underlying.storage[..i + 1]) == transferredContents';
    LemmaReallocIterateResult(self, newUnderlying', i + 1, transferredContents', newSize);
  }
  lemma LemmaReallocResult(self: LinearHashMap)
    requires self.count as nat < 18446744073709551616 / 8
    requires Inv(self)
    ensures var self': LinearHashMap<_T0> := ReallocInternal(self); Inv(self') && self'.contents == self.contents && self'.underlying.count as nat < |self'.underlying.storage| - 2
    decreases self
  {
    ghost var self': LinearHashMap<_T0> := ReallocInternal(self);
    reveal_ReallocInternal();
    assert |self.contents| == self.count as nat;
    ghost var newSize: uint64 := (128 + self.count) * 4;
    ghost var newUnderlying: FixedSizeLinearHashMap<_T0> := ConstructorFromSize(newSize);
    assert |newUnderlying.storage| == newSize as nat;
    assert MapFromStorage(self.underlying.storage) == self.contents;
    UnderlyingInvImpliesMapFromStorageMatchesContents(newUnderlying, map[]);
    assert MapFromStorage(newUnderlying.storage) == map[];
    LemmaReallocIterateResult(self, newUnderlying, 0, map[], newSize);
    ghost var newUnderlying': FixedSizeLinearHashMap<_T0> := ReallocIterate(self, newUnderlying, 0);
    assert self' == self.(underlying := newUnderlying');
    assert FixedSizeInv(newUnderlying');
    assert UnderlyingInv(self', newUnderlying');
    assert UnderlyingContentsMatchesContents(newUnderlying', self.contents);
    assert MapFromStorage(newUnderlying'.storage) == self.contents;
    assert newUnderlying'.count as nat < |newUnderlying'.storage| - 2;
    assert self'.underlying.count as nat < |self'.underlying.storage| - 2;
    assert self'.contents == self.contents;
    assert self'.count == self.count;
    assert self'.count <= self'.underlying.count;
    assert Inv(self');
  }
  function {:opaque} {:fuel 0, 0} InsertAndGetOld<V>(self: LinearHashMap<V>, key: uint64, value: V): (res: (LinearHashMap<V>, Option<V>))
    requires Inv(self)
    requires self.count as nat < 18446744073709551616 / 8
    ensures var (self': LinearHashMap<V>, replaced: Option<V>) := res; Inv(self') && self'.contents == self.contents[key := value] && self'.count as nat == self.count as nat + (if replaced.Some? then 0 else 1) && (replaced.Some? ==> MapsTo(self.contents, key, replaced.value)) && (replaced.None? ==> key !in self.contents)
    decreases self, key
  {
    var self1: LinearHashMap<V> := if |self.underlying.storage| as uint64 / 2 <= self.underlying.count then Realloc(self) else self;
    var (underlying': FixedSizeLinearHashMap<V>, replaced: Option<V>) := FixedSizeInsert(self1.underlying, key, value);
    var self': LinearHashMap<V> := self1.(underlying := underlying').(contents := self1.contents[key := value]).(count := if replaced.None? then self1.count + 1 else self1.count);
    LemmaFixedSizeInsertResult(self1.underlying, key, value);
    UnderlyingInvImpliesMapFromStorageMatchesContents(self'.underlying, self'.contents);
    (self', replaced)
  }
  function {:opaque} {:fuel 0, 0} Insert<V>(self: LinearHashMap<V>, key: uint64, value: V): (self': LinearHashMap<V>)
    requires Inv(self)
    requires self.count as nat < 18446744073709551616 / 8
    ensures Inv(self') && self'.contents == self.contents[key := value] && (self'.count as nat == self.count as nat || self'.count as nat == self.count as nat + 1)
    decreases self, key
  {
    InsertAndGetOld(self, key, value).0
  }
  function RemoveInternal<V>(self: LinearHashMap<V>, key: uint64): (res: (LinearHashMap<V>, Option<V>))
    requires Inv(self)
    ensures var (self': LinearHashMap<V>, removed: Option<V>) := res; (self'.underlying, removed) == FixedSizeRemove(self.underlying, key) && FixedSizeInv(self'.underlying) && self'.underlying.contents == (if key in self.underlying.contents then self.underlying.contents[key := None] else self.underlying.contents) && removed == (if key in self.underlying.contents && self.underlying.contents[key].Some? then Some(self.underlying.contents[key].value) else None) && self'.underlying.count == self.underlying.count
    decreases self, key
  {
    var (underlying': FixedSizeLinearHashMap<V>, removed: Option<V>) := FixedSizeRemove(self.underlying, key);
    LemmaFixedSizeRemoveResult(self.underlying, key);
    var self': LinearHashMap<V> := self.(underlying := underlying').(contents := map k: uint64 {:trigger self.contents[k]} {:trigger k in self.contents} | k in self.contents && k != key :: self.contents[k]).(count := if removed.Some? then self.count - 1 else self.count);
    (self', removed)
  }
  lemma RemoveCountCorrect<V>(self: LinearHashMap<V>, key: uint64, res: (LinearHashMap<V>, Option<V>))
    requires Inv(self)
    requires res == RemoveInternal(self, key)
    ensures var (self': LinearHashMap<V>, removed: Option<V>) := res; self'.count as nat == |self'.contents|
    decreases self, key, res
  {
    var (self': LinearHashMap<V>, removed: Option<V>) := res;
    if removed.Some? {
      assert key in self.contents;
      assert self'.contents.Keys <= self.contents.Keys;
      assert |self.contents| == self'.count as nat + 1;
      assert |self.contents.Keys| == self'.count as nat + 1;
      assert |self.contents.Keys - {key}| == |self.contents.Keys| - |{key}|;
      assert self.contents.Keys - {key} == self'.contents.Keys;
      assert |self'.contents| == |self.contents| - 1;
      assert |self'.contents| == self'.count as nat;
    } else {
      assert key !in self.contents;
      assert self'.contents == self.contents;
      assert |self'.contents| == self'.count as nat;
    }
  }
  function RemoveAndGet<V>(self: LinearHashMap<V>, key: uint64): (res: (LinearHashMap<V>, Option<V>))
    requires Inv(self)
    ensures var (self': LinearHashMap<V>, removed: Option<V>) := res; Inv(self') && self'.contents == (if key in self.contents then map k: uint64 {:trigger self.contents[k]} {:trigger k in self.contents} | k in self.contents && k != key :: self.contents[k] else self.contents) && removed == if key in self.contents then Some(self.contents[key]) else None
    decreases self, key
  {
    var (self': LinearHashMap<V>, removed: Option<V>) := RemoveInternal(self, key);
    LemmaFixedSizeRemoveResult(self.underlying, key);
    RemoveCountCorrect(self, key, (self', removed));
    UnderlyingInvImpliesMapFromStorageMatchesContents(self'.underlying, self'.contents);
    (self', removed)
  }
  function Remove<V>(self: LinearHashMap<V>, key: uint64): (self': LinearHashMap<V>)
    requires Inv(self)
    ensures Inv(self') && self'.contents == if key in self.contents then map k: uint64 {:trigger self.contents[k]} {:trigger k in self.contents} | k in self.contents && k != key :: self.contents[k] else self.contents
    decreases self, key
  {
    RemoveAndGet(self, key).0
  }
  function Get<V>(self: LinearHashMap<V>, key: uint64): (found: Option<V>)
    requires Inv(self)
    ensures if key in self.contents then found == Some(self.contents[key]) else found.None?
    ensures found.Some? <==> key in self.contents
    decreases self, key
  {
    var found: Option<V> := FixedSizeGet(self.underlying, key);
    LemmaFixedSizeGetResult(self.underlying, key);
    found
  }
  predicate NextExplainedByI<V>(self: LinearHashMap<V>, i: uint64, output: IteratorOutput<V>)
    decreases self, i, output
  {
    (output.Next? ==>
      i as int < |self.underlying.storage| &&
      self.underlying.storage[i].Entry? &&
      self.underlying.storage[i].key == output.key &&
      self.underlying.storage[i].value == output.value) &&
    (output.Done? ==>
      i as int == |self.underlying.storage|)
  }
  predicate ValidI<V>(self: LinearHashMap<V>, it: Iterator<V>)
    decreases self, it
  {
    true &&
    0 <= it.i as int <= |self.underlying.storage|
  }
  predicate EachReturnedKeyExplainedByPassedIndex<V>(self: LinearHashMap<V>, s: set<uint64>, i: uint64)
    requires 0 <= i as int <= |self.underlying.storage|
    decreases self, s, i
  {
    forall key: uint64 {:trigger key in s} | key in s :: 
      exists j: int {:trigger self.underlying.storage[j]} | 0 <= j < i as int :: 
        self.underlying.storage[j].Entry? &&
        key == self.underlying.storage[j].key
  }
  protected predicate WFIter<V>(self: LinearHashMap<V>, it: Iterator<V>)
    ensures WFIter(self, it) ==> it.next.Done? ==> it.s == self.contents.Keys
    ensures WFIter(self, it) ==> it.next.Next? ==> MapsTo(self.contents, it.next.key, it.next.value)
    ensures WFIter(self, it) ==> it.next.Next? ==> it.next.key !in it.s
    ensures WFIter(self, it) ==> it.s <= self.contents.Keys
    decreases self, it
  {
    ValidI(self, it) &&
    NextExplainedByI(self, it.i, it.next) &&
    (it.next.Done? ==>
      it.s == self.contents.Keys) &&
    (forall j: int {:trigger self.underlying.storage[j]} | 0 <= j < it.i as int :: 
      self.underlying.storage[j].Entry? ==>
        self.underlying.storage[j].key in it.s) &&
    EachReturnedKeyExplainedByPassedIndex(self, it.s, it.i) &&
    it.decreaser == (|self.underlying.storage| - it.i as int) as ORDINAL &&
    (it.next.Next? ==>
      MapsTo(self.contents, it.next.key, it.next.value)) &&
    (it.next.Next? ==>
      it.next.key !in it.s) &&
    it.s <= self.contents.Keys
  }
  protected predicate WFSimpleIter<V>(self: LinearHashMap<V>, it: SimpleIterator)
    ensures WFSimpleIter(self, it) ==> it.s <= self.contents.Keys
    decreases self, it
  {
    0 <= it.i as int <= |self.underlying.storage| &&
    (it.i as int == |self.underlying.storage| ==>
      it.s == self.contents.Keys) &&
    (it.i as int < |self.underlying.storage| ==>
      self.underlying.storage[it.i].Entry?) &&
    (forall j: int {:trigger self.underlying.storage[j]} | 0 <= j < it.i as int :: 
      self.underlying.storage[j].Entry? ==>
        self.underlying.storage[j].key in it.s) &&
    EachReturnedKeyExplainedByPassedIndex(self, it.s, it.i) &&
    it.decreaser == (|self.underlying.storage| - it.i as int) as ORDINAL &&
    (it.i as int < |self.underlying.storage| ==>
      MapsTo(self.contents, self.underlying.storage[it.i].key, self.underlying.storage[it.i].value) &&
      self.underlying.storage[it.i].key !in it.s) &&
    it.s <= self.contents.Keys
  }
  function indexOutput<V>(self: LinearHashMap<V>, i: uint64): (next: IteratorOutput<V>)
    requires 0 <= i as int <= |self.underlying.storage|
    requires i as int < |self.underlying.storage| ==> self.underlying.storage[i].Entry?
    decreases self, i
  {
    if i as int == |self.underlying.storage| then
      Done
    else
      Next(self.underlying.storage[i].key, self.underlying.storage[i].value)
  }
  protected function SimpleIterOutput<V>(self: LinearHashMap<V>, it: SimpleIterator): (next: IteratorOutput<V>)
    requires WFSimpleIter(self, it)
    ensures next.Done? ==> it.s == self.contents.Keys
    ensures next.Next? ==> MapsTo(self.contents, next.key, next.value)
    ensures next.Next? ==> next.key !in it.s
    decreases self, it
  {
    indexOutput(self, it.i)
  }
  lemma LemmaSimpleIterOutputReveal<V>(self: LinearHashMap<V>, it: SimpleIterator)
    requires WFSimpleIter(self, it)
    ensures SimpleIterOutput(self, it) == indexOutput(self, it.i)
    decreases self, it
  {
  }
  lemma LemmaWFIterImpliesILt<V>(self: LinearHashMap<V>, it: Iterator<V>)
    requires WFIter(self, it)
    ensures it.next.Next? ==> it.i as int < |self.underlying.storage|
    decreases self, it
  {
  }
  lemma LemmaWFSimpleIterImpliesEntry<V>(self: LinearHashMap<V>, it: SimpleIterator)
    requires WFSimpleIter(self, it)
    ensures 0 <= it.i as int <= |self.underlying.storage| && (SimpleIterOutput(self, it).Next? ==> it.i as int < |self.underlying.storage|) && (it.i as int < |self.underlying.storage| ==> true && self.underlying.storage[it.i].Entry?)
    decreases self, it
  {
  }
  lemma LemmaIterNextNotInS<V>(self: LinearHashMap<V>, it: Iterator<V>)
    requires 0 <= it.i as int <= |self.underlying.storage|
    requires ValidElements(self.underlying.storage)
    requires CantEquivocateStorageKey(self.underlying.storage)
    requires NextExplainedByI(self, it.i, it.next)
    requires EachReturnedKeyExplainedByPassedIndex(self, it.s, it.i)
    ensures it.next.Next? ==> it.next.key !in it.s
    decreases self, it
  {
    if it.next.Next? {
      if it.next.key in it.s {
        ghost var j: int :| 0 <= j < it.i as int && self.underlying.storage[j].Entry? && it.next.key == self.underlying.storage[j].key;
        assert TwoNonEmptyValidSlotsWithSameKey<V>(self.underlying.storage, Slot(it.i as int), Slot(j));
      }
    }
  }
  function iterToNext<V>(self: LinearHashMap<V>, i: uint64): (res: (uint64, IteratorOutput<V>))
    requires Inv(self)
    requires 0 <= i as int <= |self.underlying.storage|
    ensures NextExplainedByI(self, res.0, res.1)
    ensures forall j: uint64 {:trigger self.underlying.storage[j]} | i <= j < res.0 :: !self.underlying.storage[j].Entry?
    ensures i <= res.0
    decreases |self.underlying.storage| - i as int
  {
    if i as int == |self.underlying.storage| then
      (i, Done)
    else if self.underlying.storage[i].Entry? then
      (i, Next(self.underlying.storage[i].key, self.underlying.storage[i].value))
    else
      iterToNext(self, i + 1)
  }
  function simpleIterToNext<V>(self: LinearHashMap<V>, i: uint64): (i': uint64)
    requires Inv(self)
    requires 0 <= i as int <= |self.underlying.storage|
    ensures 0 <= i' as int <= |self.underlying.storage|
    ensures forall j: uint64 {:trigger self.underlying.storage[j]} | i <= j < i' :: !self.underlying.storage[j].Entry?
    ensures i' as int < |self.underlying.storage| ==> self.underlying.storage[i'].Entry?
    ensures i <= i'
    decreases |self.underlying.storage| - i as int
  {
    if i as int == |self.underlying.storage| then
      i
    else if self.underlying.storage[i].Entry? then
      i
    else
      simpleIterToNext(self, i + 1)
  }
  lemma  lemmaIterToNextValidKeyValuePair<V>(self: LinearHashMap<V>, i: uint64)
    requires Inv(self)
    requires 0 <= i as int <= |self.underlying.storage|
    ensures iterToNext(self, i).1.Next? ==> MapsTo(self.contents, iterToNext(self, i).1.key, iterToNext(self, i).1.value)
    decreases self, i
  {
    ghost var j: uint64 := iterToNext(self, i).0;
    ghost var next: IteratorOutput<V> := iterToNext(self, i).1;
    if next.Next? {
      UnderlyingInvImpliesMapFromStorageMatchesContents(self.underlying, self.contents);
      CantEquivocateMapFromStorageKey(self.underlying);
      MapFromStorageProperties(self.underlying.storage, self.contents);
      assert self.underlying.storage[Slot(j as int).slot].value == next.value;
    }
  }
  function {:opaque} {:fuel 0, 0} IterStart<V>(self: LinearHashMap<V>): (it': Iterator<V>)
    requires Inv(self)
    ensures WFIter(self, it')
    ensures it'.s == {}
    decreases self
  {
    lemmaIterToNextValidKeyValuePair(self, 0);
    var (i: uint64, next: IteratorOutput<V>) := iterToNext(self, 0);
    var it': Iterator<V> := Iterator(i, {}, (|self.underlying.storage| - i as int) as ORDINAL, next);
    LemmaIterNextNotInS(self, it');
    it'
  }
  function {:opaque} {:fuel 0, 0} SimpleIterStart<V>(self: LinearHashMap<V>): (it': SimpleIterator)
    requires Inv(self)
    ensures WFSimpleIter(self, it')
    ensures it'.s == {}
    decreases self
  {
    lemmaIterToNextValidKeyValuePair(self, 0);
    var i: uint64 := simpleIterToNext(self, 0);
    var it': SimpleIterator := SimpleIterator(i, {}, (|self.underlying.storage| - i as int) as ORDINAL);
    LemmaIterNextNotInS(self, Iterator(it'.i, it'.s, it'.decreaser, indexOutput(self, it'.i)));
    it'
  }
  function {:opaque} {:fuel 0, 0} IterInc<V>(self: LinearHashMap<V>, it: Iterator<V>): (it': Iterator<V>)
    requires Inv(self)
    requires WFIter(self, it)
    requires it.next.Next?
    ensures WFIter(self, it')
    ensures it'.s == it.s + {it.next.key}
    ensures it'.next.Done? ==> it'.s == self.contents.Keys
    ensures it'.decreaser < it.decreaser
    decreases self, it
  {
    lemmaIterToNextValidKeyValuePair(self, it.i + 1);
    var (i: uint64, next: IteratorOutput<V>) := iterToNext(self, it.i + 1);
    var it': Iterator<V> := Iterator(i, it.s + {it.next.key}, (|self.underlying.storage| - i as int) as ORDINAL, next);
    assert forall key: uint64 {:trigger key in it'.s} | key in it'.s :: exists j: int {:trigger self.underlying.storage[j]} | 0 <= j < it'.i as int :: self.underlying.storage[j].Entry? && key == self.underlying.storage[j].key;
    assert it'.next.Done? ==> it'.s == self.contents.Keys;
    LemmaIterNextNotInS(self, it');
    it'
  }
  function {:opaque} {:fuel 0, 0} SimpleIterInc<V>(self: LinearHashMap<V>, it: SimpleIterator): (it': SimpleIterator)
    requires Inv(self)
    requires WFSimpleIter(self, it)
    requires SimpleIterOutput(self, it).Next?
    ensures WFSimpleIter(self, it')
    ensures it'.s == it.s + {SimpleIterOutput(self, it).key}
    ensures it'.decreaser < it.decreaser
    decreases self, it
  {
    lemmaIterToNextValidKeyValuePair(self, it.i + 1);
    var i: uint64 := simpleIterToNext(self, it.i + 1);
    var it': SimpleIterator := SimpleIterator(i, it.s + {SimpleIterOutput(self, it).key}, (|self.underlying.storage| - i as int) as ORDINAL);
    assert forall key: uint64 {:trigger key in it'.s} | key in it'.s :: exists j: int {:trigger self.underlying.storage[j]} | 0 <= j < it'.i as int :: self.underlying.storage[j].Entry? && key == self.underlying.storage[j].key;
    LemmaIterNextNotInS(self, Iterator(it'.i, it'.s, it'.decreaser, indexOutput(self, it'.i)));
    it'
  }
  lemma LemmaIterIndexLtCount<V>(self: LinearHashMap<V>, it: Iterator<V>)
    requires Inv(self)
    requires WFIter(self, it)
    ensures it.next.Next? ==> |it.s| < self.count as int
    decreases self, it
  {
    if it.next.Next? {
      ProperSubsetImpliesSmallerCardinality(it.s, self.contents.Keys);
    }
  }
  function MaxKeyIterate<V>(self: LinearHashMap<V>, it: Iterator<V>, m: uint64): (res: uint64)
    requires Inv(self)
    requires WFIter(self, it)
    requires forall key: uint64 {:trigger key in it.s} | key in it.s :: key <= m
    ensures forall key: uint64 {:trigger key in self.contents} | key in self.contents :: key <= res
    decreases it.decreaser
  {
    if it.next.Done? then
      m
    else
      var key: uint64 := it.next.key; MaxKeyIterate(self, IterInc(self, it), if m < key then key else m)
  }
  function {:opaque} {:fuel 0, 0} MaxKey<V>(self: LinearHashMap<V>): (res: uint64)
    requires Inv(self)
    ensures forall key: uint64 {:trigger key in self.contents} | key in self.contents :: key <= res
    decreases self
  {
    MaxKeyIterate(self, IterStart(self), 0)
  }
  function {:opaque} {:fuel 0, 0} UpdateByIter<V>(self: LinearHashMap<V>, it: SimpleIterator, value: V): (self': LinearHashMap<V>)
    requires Inv(self)
    requires WFSimpleIter(self, it)
    requires SimpleIterOutput(self, it).Next?
    ensures Inv(self')
    ensures self'.contents == self.contents[SimpleIterOutput(self, it).key := value]
    ensures self'.count == self.count
    decreases self, it
  {
    FixedSizeUpdateBySlotResult(self.underlying, it.i, value);
    var underlying: FixedSizeLinearHashMap<V> := FixedSizeUpdateBySlot(self.underlying, it.i, value);
    var self': LinearHashMap<V> := LinearHashMap(underlying, self.count, self.contents[SimpleIterOutput(self, it).key := value]);
    UnderlyingInvImpliesMapFromStorageMatchesContents(self'.underlying, self'.contents);
    self'
  }
  lemma UpdatePreservesSimpleIter<V>(self: LinearHashMap<V>, it: SimpleIterator, value: V, preserved: SimpleIterator)
    requires UpdateByIter.requires(self, it, value)
    requires WFSimpleIter(self, preserved)
    ensures WFSimpleIter(UpdateByIter(self, it, value), preserved)
    decreases self, it, preserved
  {
    reveal_UpdateByIter();
    ghost var self': LinearHashMap<V> := UpdateByIter(self, it, value);
    forall key: uint64 {:trigger key in preserved.s} | key in preserved.s
      ensures exists j: int {:trigger self'.underlying.storage[j]} | 0 <= j < preserved.i as int :: self'.underlying.storage[j].Entry? && key == self'.underlying.storage[j].key
    {
      assert key in self.contents;
      ghost var j: int :| 0 <= j < preserved.i as int && self.underlying.storage[j].Entry? && key == self.underlying.storage[j].key;
      assert self'.underlying.storage[j].Entry?;
      assert key == self'.underlying.storage[j].key;
    }
  }
  function setUpTo<V>(self: LinearHashMap<V>, i: int): set<uint64>
    requires 0 <= i <= |self.underlying.storage|
    decreases self, i
  {
    set j: int {:trigger self.underlying.storage[j]} | 0 <= j < i && self.underlying.storage[j].Entry? :: self.underlying.storage[j].key
  }
  lemma setUpToLeContents<V>(self: LinearHashMap<V>, i: int)
    requires Inv(self)
    requires 0 <= i <= |self.underlying.storage|
    ensures setUpTo(self, i) <= self.contents.Keys
    decreases self, i
  {
    forall j: int {:trigger self.underlying.storage[j]} | 0 <= j < i && self.underlying.storage[j].Entry?
      ensures self.underlying.storage[j].key in self.contents
    {
      ghost var key: uint64 := self.underlying.storage[j].key;
      ghost var slot: Slot := Slot(j);
      assert ValidSlot(|self.underlying.storage|, slot);
      CantEquivocateMapFromStorageKey(self.underlying);
      MapFromStorageProperties(self.underlying.storage, self.contents);
    }
  }
  function {:opaque} {:fuel 0, 0} FindSimpleIter<V>(self: LinearHashMap<V>, key: uint64): (it: SimpleIterator)
    requires Inv(self)
    ensures WFSimpleIter(self, it)
    ensures key in self.contents ==> SimpleIterOutput(self, it) == Next(key, self.contents[key])
    ensures key !in self.contents ==> SimpleIterOutput(self, it) == Done
    decreases self, key
  {
    var idx: uint64 := Probe(self.underlying, key);
    var i: uint64 := if self.underlying.storage[idx].Entry? then idx else |self.underlying.storage| as uint64;
    var it: SimpleIterator := SimpleIterator(i, setUpTo(self, i as int), (|self.underlying.storage| - i as int) as ORDINAL);
    assert WFSimpleIter(self, it) && (key in self.contents ==> SimpleIterOutput(self, it) == Next(key, self.contents[key])) && (key !in self.contents ==> SimpleIterOutput(self, it) == Done) by {
      ghost var result: ProbeResult<V> := LemmaProbeResult(self.underlying, key);
      if it.i as int < |self.underlying.storage| {
        if self.underlying.storage[it.i].key in it.s {
          ghost var j: uint64 :| 0 <= j < it.i && self.underlying.storage[j].Entry? && self.underlying.storage[j].key == key;
          assert TwoNonEmptyValidSlotsWithSameKey(self.underlying.storage, Slot(j as int), Slot(it.i as int));
        }
      }
      setUpToLeContents(self, i as int);
    }
    it
  }
}